/* Generated by /Users/thiennd/Desktop/study-documents/20192/20192-excercies/DistributedSystem/OpenDDS-3.14/bin/opendds_idl version 3.14 (ACE version 6.2a_p17) running on input file DdsDcpsInfoUtils.idl */
#include "DCPS/DdsDcps_pch.h"
#include "DdsDcpsInfoUtilsTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */


/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: ParticipantLocation */


/* End TYPEDEF: ParticipantLocation */


/* Begin TYPEDEF: OctetGuidArray16 */


/* End TYPEDEF: OctetGuidArray16 */


/* Begin CONST: LOCATION_LOCAL */


/* End CONST: LOCATION_LOCAL */


/* Begin CONST: LOCATION_ICE */


/* End CONST: LOCATION_ICE */


/* Begin CONST: LOCATION_RELAY */


/* End CONST: LOCATION_RELAY */


/* Begin STRUCT: ParticipantLocationBuiltinTopicData */


/* End STRUCT: ParticipantLocationBuiltinTopicData */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: RepoId */


/* End TYPEDEF: RepoId */


/* Begin TYPEDEF: TransportBLOB */


/* End TYPEDEF: TransportBLOB */


/* Begin STRUCT: TransportLocator */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::TransportLocator& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.transport_type.in()) + 1;
  gen_find_size(stru.data, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportLocator& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.transport_type.in())
    && (strm << stru.data);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportLocator& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.transport_type.out())
    && (strm >> stru.data);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::TransportLocator> : MetaStruct {
  typedef OpenDDS::DCPS::TransportLocator T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::TransportLocator& typed = *static_cast<const OpenDDS::DCPS::TransportLocator*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "transport_type") == 0) {
      return typed.transport_type.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "transport_type") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'transport_type' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'transport_type' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'transport_type' contents could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportBLOB*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::TransportLocator");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "transport_type") == 0) {
      return make_field_cmp(&T::transport_type, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"transport_type", "data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "transport_type") == 0) {
      return &static_cast<const T*>(stru)->transport_type;
    }
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "transport_type") == 0) {
      static_cast<T*>(lhs)->transport_type = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data") == 0) {
      static_cast<T*>(lhs)->data = *static_cast<const OpenDDS::DCPS::TransportBLOB*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "transport_type") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->transport_type.in(), static_cast<const T*>(rhs)->transport_type.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::TransportLocator>()
{
  static MetaStructImpl<OpenDDS::DCPS::TransportLocator> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportLocator*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::TransportLocator>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TransportLocator */


/* Begin TYPEDEF: TransportLocatorSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::TransportLocatorSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportLocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportLocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportLocatorSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocator*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: TransportLocatorSeq */


/* Begin STRUCT: IncompatibleQosStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::IncompatibleQosStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.total_count);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.count_since_last_send);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.last_policy_id);
  gen_find_size(stru.policies, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::IncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.total_count)
    && (strm << stru.count_since_last_send)
    && (strm << stru.last_policy_id)
    && (strm << stru.policies);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::IncompatibleQosStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.total_count)
    && (strm >> stru.count_since_last_send)
    && (strm >> stru.last_policy_id)
    && (strm >> stru.policies);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus> : MetaStruct {
  typedef OpenDDS::DCPS::IncompatibleQosStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::IncompatibleQosStatus& typed = *static_cast<const OpenDDS::DCPS::IncompatibleQosStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "total_count") == 0) {
      return typed.total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return typed.count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return typed.last_policy_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'total_count' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'total_count' could not be skipped");
      }
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'count_since_last_send' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'count_since_last_send' could not be skipped");
      }
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'last_policy_id' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'last_policy_id' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<DDS::QosPolicyCountSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::IncompatibleQosStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "total_count") == 0) {
      return make_field_cmp(&T::total_count, next);
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return make_field_cmp(&T::count_since_last_send, next);
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return make_field_cmp(&T::last_policy_id, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"total_count", "count_since_last_send", "last_policy_id", "policies", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "total_count") == 0) {
      return &static_cast<const T*>(stru)->total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return &static_cast<const T*>(stru)->count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return &static_cast<const T*>(stru)->last_policy_id;
    }
    if (std::strcmp(field, "policies") == 0) {
      return &static_cast<const T*>(stru)->policies;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "total_count") == 0) {
      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      static_cast<T*>(lhs)->count_since_last_send = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      static_cast<T*>(lhs)->last_policy_id = *static_cast<const DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "policies") == 0) {
      static_cast<T*>(lhs)->policies = *static_cast<const DDS::QosPolicyCountSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "total_count") == 0) {
      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
    }
    if (std::strcmp(field, "count_since_last_send") == 0) {
      return static_cast<const T*>(lhs)->count_since_last_send == static_cast<const T*>(rhs)->count_since_last_send;
    }
    if (std::strcmp(field, "last_policy_id") == 0) {
      return static_cast<const T*>(lhs)->last_policy_id == static_cast<const T*>(rhs)->last_policy_id;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::IncompatibleQosStatus>()
{
  static MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::IncompatibleQosStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: IncompatibleQosStatus */


/* Begin STRUCT: AddDomainStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::AddDomainStatus& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.id, size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.federated));
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::AddDomainStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.id)
    && (strm << ACE_OutputCDR::from_boolean(stru.federated));
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::AddDomainStatus& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.id)
    && (strm >> ACE_InputCDR::to_boolean(stru.federated));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::AddDomainStatus> : MetaStruct {
  typedef OpenDDS::DCPS::AddDomainStatus T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::AddDomainStatus& typed = *static_cast<const OpenDDS::DCPS::AddDomainStatus*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "id.", 3) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.id, field + 3);
    }
    if (std::strcmp(field, "federated") == 0) {
      return typed.federated;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "id.", 3) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 3);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) {
        throw std::runtime_error("Field 'id' could not be skipped");
      }
    }
    if (std::strcmp(field, "federated") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'federated' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'federated' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::AddDomainStatus");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "id.", 3) == 0) {
      return make_struct_cmp(&T::id, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 3), next);
    }
    if (std::strcmp(field, "federated") == 0) {
      return make_field_cmp(&T::federated, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"id", "federated", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "id") == 0) {
      return &static_cast<const T*>(stru)->id;
    }
    if (std::strcmp(field, "federated") == 0) {
      return &static_cast<const T*>(stru)->federated;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "id") == 0) {
      static_cast<T*>(lhs)->id = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "federated") == 0) {
      static_cast<T*>(lhs)->federated = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "federated") == 0) {
      return static_cast<const T*>(lhs)->federated == static_cast<const T*>(rhs)->federated;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::AddDomainStatus>()
{
  static MetaStructImpl<OpenDDS::DCPS::AddDomainStatus> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::AddDomainStatus*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::AddDomainStatus>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: AddDomainStatus */


/* Begin ENUM: TopicStatus */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::DCPS::TopicStatus& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::TopicStatus& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::DCPS::TopicStatus>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_DCPS_TopicStatus_names[] = {
  "CREATED",
  "ENABLED",
  "FOUND",
  "NOT_FOUND",
  "REMOVED",
  "CONFLICTING_TYPENAME",
  "PRECONDITION_NOT_MET",
  "INTERNAL_ERROR",
  "TOPIC_DISABLED"
};
const size_t gen_OpenDDS_DCPS_TopicStatus_names_size = 9;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: TopicStatus */


/* Begin STRUCT: WriterAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::WriterAssociation& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.writerTransInfo, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.pubQos, size, padding);
  gen_find_size(stru.writerQos, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::WriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.writerTransInfo)
    && (strm << stru.writerId)
    && (strm << stru.pubQos)
    && (strm << stru.writerQos);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::WriterAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.writerTransInfo)
    && (strm >> stru.writerId)
    && (strm >> stru.pubQos)
    && (strm >> stru.writerQos);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::WriterAssociation> : MetaStruct {
  typedef OpenDDS::DCPS::WriterAssociation T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::WriterAssociation& typed = *static_cast<const OpenDDS::DCPS::WriterAssociation*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "pubQos.", 7) == 0) {
      return getMetaStruct<DDS::PublisherQos>().getValue(&typed.pubQos, field + 7);
    }
    if (std::strncmp(field, "writerQos.", 10) == 0) {
      return getMetaStruct<DDS::DataWriterQos>().getValue(&typed.writerQos, field + 10);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "pubQos.", 7) == 0) {
      return getMetaStruct<DDS::PublisherQos>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::PublisherQos*>(0))) {
        throw std::runtime_error("Field 'pubQos' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerQos.", 10) == 0) {
      return getMetaStruct<DDS::DataWriterQos>().getValue(ser, field + 10);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::DataWriterQos*>(0))) {
        throw std::runtime_error("Field 'writerQos' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::WriterAssociation");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "pubQos.", 7) == 0) {
      return make_struct_cmp(&T::pubQos, getMetaStruct<DDS::PublisherQos>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "writerQos.", 10) == 0) {
      return make_struct_cmp(&T::writerQos, getMetaStruct<DDS::DataWriterQos>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"writerTransInfo", "writerId", "pubQos", "writerQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "writerTransInfo") == 0) {
      return &static_cast<const T*>(stru)->writerTransInfo;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "pubQos") == 0) {
      return &static_cast<const T*>(stru)->pubQos;
    }
    if (std::strcmp(field, "writerQos") == 0) {
      return &static_cast<const T*>(stru)->writerQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "writerTransInfo") == 0) {
      static_cast<T*>(lhs)->writerTransInfo = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "pubQos") == 0) {
      static_cast<T*>(lhs)->pubQos = *static_cast<const DDS::PublisherQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerQos") == 0) {
      static_cast<T*>(lhs)->writerQos = *static_cast<const DDS::DataWriterQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::WriterAssociation>()
{
  static MetaStructImpl<OpenDDS::DCPS::WriterAssociation> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::WriterAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::WriterAssociation>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WriterAssociation */


/* Begin STRUCT: ReaderAssociation */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ReaderAssociation& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.readerTransInfo, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.subQos, size, padding);
  gen_find_size(stru.readerQos, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.filterClassName.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.filterExpression.in()) + 1;
  gen_find_size(stru.exprParams, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.readerTransInfo)
    && (strm << stru.readerId)
    && (strm << stru.subQos)
    && (strm << stru.readerQos)
    && (strm << stru.filterClassName.in())
    && (strm << stru.filterExpression.in())
    && (strm << stru.exprParams);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ReaderAssociation& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.readerTransInfo)
    && (strm >> stru.readerId)
    && (strm >> stru.subQos)
    && (strm >> stru.readerQos)
    && (strm >> stru.filterClassName.out())
    && (strm >> stru.filterExpression.out())
    && (strm >> stru.exprParams);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::ReaderAssociation> : MetaStruct {
  typedef OpenDDS::DCPS::ReaderAssociation T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::ReaderAssociation& typed = *static_cast<const OpenDDS::DCPS::ReaderAssociation*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "subQos.", 7) == 0) {
      return getMetaStruct<DDS::SubscriberQos>().getValue(&typed.subQos, field + 7);
    }
    if (std::strncmp(field, "readerQos.", 10) == 0) {
      return getMetaStruct<DDS::DataReaderQos>().getValue(&typed.readerQos, field + 10);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return typed.filterClassName.in();
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return typed.filterExpression.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "subQos.", 7) == 0) {
      return getMetaStruct<DDS::SubscriberQos>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::SubscriberQos*>(0))) {
        throw std::runtime_error("Field 'subQos' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerQos.", 10) == 0) {
      return getMetaStruct<DDS::DataReaderQos>().getValue(ser, field + 10);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::DataReaderQos*>(0))) {
        throw std::runtime_error("Field 'readerQos' could not be skipped");
      }
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'filterClassName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'filterClassName' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'filterClassName' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'filterExpression' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'filterExpression' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'filterExpression' contents could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<DDS::StringSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::ReaderAssociation");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "subQos.", 7) == 0) {
      return make_struct_cmp(&T::subQos, getMetaStruct<DDS::SubscriberQos>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "readerQos.", 10) == 0) {
      return make_struct_cmp(&T::readerQos, getMetaStruct<DDS::DataReaderQos>().create_qc_comparator(field + 10), next);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return make_field_cmp(&T::filterClassName, next);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return make_field_cmp(&T::filterExpression, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"readerTransInfo", "readerId", "subQos", "readerQos", "filterClassName", "filterExpression", "exprParams", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "readerTransInfo") == 0) {
      return &static_cast<const T*>(stru)->readerTransInfo;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "subQos") == 0) {
      return &static_cast<const T*>(stru)->subQos;
    }
    if (std::strcmp(field, "readerQos") == 0) {
      return &static_cast<const T*>(stru)->readerQos;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return &static_cast<const T*>(stru)->filterClassName;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return &static_cast<const T*>(stru)->filterExpression;
    }
    if (std::strcmp(field, "exprParams") == 0) {
      return &static_cast<const T*>(stru)->exprParams;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "readerTransInfo") == 0) {
      static_cast<T*>(lhs)->readerTransInfo = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "subQos") == 0) {
      static_cast<T*>(lhs)->subQos = *static_cast<const DDS::SubscriberQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerQos") == 0) {
      static_cast<T*>(lhs)->readerQos = *static_cast<const DDS::DataReaderQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      static_cast<T*>(lhs)->filterClassName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      static_cast<T*>(lhs)->filterExpression = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "exprParams") == 0) {
      static_cast<T*>(lhs)->exprParams = *static_cast<const DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "filterClassName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterClassName.in(), static_cast<const T*>(rhs)->filterClassName.in());
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterExpression.in(), static_cast<const T*>(rhs)->filterExpression.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::ReaderAssociation>()
{
  static MetaStructImpl<OpenDDS::DCPS::ReaderAssociation> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ReaderAssociation*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::ReaderAssociation>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReaderAssociation */


/* Begin TYPEDEF: WriterIdSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::WriterIdSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::WriterIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::WriterIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::WriterIdSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: WriterIdSeq */


/* Begin TYPEDEF: ReaderIdSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ReaderIdSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReaderIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ReaderIdSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ReaderIdSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ReaderIdSeq */


/* Begin TYPEDEF: OctetArray16 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::OctetArray16_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 16 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::OctetArray16_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 16);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::OctetArray16_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 16);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::OctetArray16_forany*)
{
  ACE_UNUSED_ARG(ser);
  return ser.skip(static_cast<ACE_UINT16>(16), 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: Locator_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::Locator_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::OctetArray16_forany stru_address(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.address));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.kind);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.port);
  gen_find_size(stru_address, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::Locator_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::OctetArray16_forany stru_address(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.address));
  return (strm << stru.kind)
    && (strm << stru.port)
    && (strm << stru_address);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::Locator_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::OctetArray16_forany stru_address(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.address));
  return (strm >> stru.kind)
    && (strm >> stru.port)
    && (strm >> stru_address);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::Locator_t> : MetaStruct {
  typedef OpenDDS::DCPS::Locator_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::Locator_t& typed = *static_cast<const OpenDDS::DCPS::Locator_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "kind") == 0) {
      return typed.kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return typed.port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'kind' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'kind' could not be skipped");
      }
    }
    if (std::strcmp(field, "port") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'port' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'port' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::OctetArray16_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::Locator_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "kind") == 0) {
      return make_field_cmp(&T::kind, next);
    }
    if (std::strcmp(field, "port") == 0) {
      return make_field_cmp(&T::port, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"kind", "port", "address", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "kind") == 0) {
      return &static_cast<const T*>(stru)->kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return &static_cast<const T*>(stru)->port;
    }
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->address;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "kind") == 0) {
      static_cast<T*>(lhs)->kind = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "port") == 0) {
      static_cast<T*>(lhs)->port = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "address") == 0) {
      OpenDDS::DCPS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->address;
      const OpenDDS::DCPS::OctetArray16* rhsArr = static_cast<const OpenDDS::DCPS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "kind") == 0) {
      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
    }
    if (std::strcmp(field, "port") == 0) {
      return static_cast<const T*>(lhs)->port == static_cast<const T*>(rhs)->port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::Locator_t>()
{
  static MetaStructImpl<OpenDDS::DCPS::Locator_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::Locator_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::Locator_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Locator_t */


/* Begin TYPEDEF: LocatorSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::LocatorSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::LocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::LocatorSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::LocatorSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::Locator_t*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LocatorSeq */


/* Begin TYPEDEF: String256 */


/* End TYPEDEF: String256 */


/* Begin STRUCT: ContentFilterProperty_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ContentFilterProperty_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.contentFilteredTopicName.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.relatedTopicName.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.filterClassName.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.filterExpression.in()) + 1;
  gen_find_size(stru.expressionParameters, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ContentFilterProperty_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_string(stru.contentFilteredTopicName.in(), 256))
    && (strm << ACE_OutputCDR::from_string(stru.relatedTopicName.in(), 256))
    && (strm << ACE_OutputCDR::from_string(stru.filterClassName.in(), 256))
    && (strm << stru.filterExpression.in())
    && (strm << stru.expressionParameters);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ContentFilterProperty_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_string(stru.contentFilteredTopicName.out(), 256))
    && (strm >> ACE_InputCDR::to_string(stru.relatedTopicName.out(), 256))
    && (strm >> ACE_InputCDR::to_string(stru.filterClassName.out(), 256))
    && (strm >> stru.filterExpression.out())
    && (strm >> stru.expressionParameters);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::ContentFilterProperty_t> : MetaStruct {
  typedef OpenDDS::DCPS::ContentFilterProperty_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::ContentFilterProperty_t& typed = *static_cast<const OpenDDS::DCPS::ContentFilterProperty_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return typed.contentFilteredTopicName.in();
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return typed.relatedTopicName.in();
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return typed.filterClassName.in();
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return typed.filterExpression.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'contentFilteredTopicName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'contentFilteredTopicName' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'contentFilteredTopicName' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'relatedTopicName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'relatedTopicName' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'relatedTopicName' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'filterClassName' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'filterClassName' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'filterClassName' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'filterExpression' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'filterExpression' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'filterExpression' contents could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<DDS::StringSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::ContentFilterProperty_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return make_field_cmp(&T::contentFilteredTopicName, next);
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return make_field_cmp(&T::relatedTopicName, next);
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return make_field_cmp(&T::filterClassName, next);
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return make_field_cmp(&T::filterExpression, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"contentFilteredTopicName", "relatedTopicName", "filterClassName", "filterExpression", "expressionParameters", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return &static_cast<const T*>(stru)->contentFilteredTopicName;
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return &static_cast<const T*>(stru)->relatedTopicName;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return &static_cast<const T*>(stru)->filterClassName;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return &static_cast<const T*>(stru)->filterExpression;
    }
    if (std::strcmp(field, "expressionParameters") == 0) {
      return &static_cast<const T*>(stru)->expressionParameters;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      static_cast<T*>(lhs)->contentFilteredTopicName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      static_cast<T*>(lhs)->relatedTopicName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      static_cast<T*>(lhs)->filterClassName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      static_cast<T*>(lhs)->filterExpression = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expressionParameters") == 0) {
      static_cast<T*>(lhs)->expressionParameters = *static_cast<const DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->contentFilteredTopicName.in(), static_cast<const T*>(rhs)->contentFilteredTopicName.in());
    }
    if (std::strcmp(field, "relatedTopicName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->relatedTopicName.in(), static_cast<const T*>(rhs)->relatedTopicName.in());
    }
    if (std::strcmp(field, "filterClassName") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterClassName.in(), static_cast<const T*>(rhs)->filterClassName.in());
    }
    if (std::strcmp(field, "filterExpression") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterExpression.in(), static_cast<const T*>(rhs)->filterExpression.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::ContentFilterProperty_t>()
{
  static MetaStructImpl<OpenDDS::DCPS::ContentFilterProperty_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ContentFilterProperty_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::ContentFilterProperty_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ContentFilterProperty_t */


/* Begin STRUCT: ReaderProxy_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::ReaderProxy_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.remoteReaderGuid, size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.expectsInlineQos));
  gen_find_size(stru.allLocators, size, padding);
  gen_find_size(stru.associatedWriters, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReaderProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.remoteReaderGuid)
    && (strm << ACE_OutputCDR::from_boolean(stru.expectsInlineQos))
    && (strm << stru.allLocators)
    && (strm << stru.associatedWriters);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::ReaderProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.remoteReaderGuid)
    && (strm >> ACE_InputCDR::to_boolean(stru.expectsInlineQos))
    && (strm >> stru.allLocators)
    && (strm >> stru.associatedWriters);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::ReaderProxy_t> : MetaStruct {
  typedef OpenDDS::DCPS::ReaderProxy_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::ReaderProxy_t& typed = *static_cast<const OpenDDS::DCPS::ReaderProxy_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.remoteReaderGuid, field + 17);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return typed.expectsInlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 17);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'remoteReaderGuid' could not be skipped");
      }
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::ReaderProxy_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
      return make_struct_cmp(&T::remoteReaderGuid, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 17), next);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return make_field_cmp(&T::expectsInlineQos, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"remoteReaderGuid", "expectsInlineQos", "allLocators", "associatedWriters", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "remoteReaderGuid") == 0) {
      return &static_cast<const T*>(stru)->remoteReaderGuid;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return &static_cast<const T*>(stru)->expectsInlineQos;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      return &static_cast<const T*>(stru)->allLocators;
    }
    if (std::strcmp(field, "associatedWriters") == 0) {
      return &static_cast<const T*>(stru)->associatedWriters;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "remoteReaderGuid") == 0) {
      static_cast<T*>(lhs)->remoteReaderGuid = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      static_cast<T*>(lhs)->expectsInlineQos = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      static_cast<T*>(lhs)->allLocators = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "associatedWriters") == 0) {
      static_cast<T*>(lhs)->associatedWriters = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return static_cast<const T*>(lhs)->expectsInlineQos == static_cast<const T*>(rhs)->expectsInlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::ReaderProxy_t>()
{
  static MetaStructImpl<OpenDDS::DCPS::ReaderProxy_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ReaderProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::ReaderProxy_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReaderProxy_t */


/* Begin STRUCT: DiscoveredReaderData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DiscoveredReaderData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsSubscriptionData, size, padding);
  gen_find_size(stru.readerProxy, size, padding);
  gen_find_size(stru.contentFilterProperty, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DiscoveredReaderData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsSubscriptionData)
    && (strm << stru.readerProxy)
    && (strm << stru.contentFilterProperty);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DiscoveredReaderData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsSubscriptionData)
    && (strm >> stru.readerProxy)
    && (strm >> stru.contentFilterProperty);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DiscoveredReaderData> : MetaStruct {
  typedef OpenDDS::DCPS::DiscoveredReaderData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DiscoveredReaderData& typed = *static_cast<const OpenDDS::DCPS::DiscoveredReaderData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
      return getMetaStruct<DDS::SubscriptionBuiltinTopicData>().getValue(&typed.ddsSubscriptionData, field + 20);
    }
    if (std::strncmp(field, "readerProxy.", 12) == 0) {
      return getMetaStruct<OpenDDS::DCPS::ReaderProxy_t>().getValue(&typed.readerProxy, field + 12);
    }
    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
      return getMetaStruct<OpenDDS::DCPS::ContentFilterProperty_t>().getValue(&typed.contentFilterProperty, field + 22);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
      return getMetaStruct<DDS::SubscriptionBuiltinTopicData>().getValue(ser, field + 20);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::SubscriptionBuiltinTopicData*>(0))) {
        throw std::runtime_error("Field 'ddsSubscriptionData' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerProxy.", 12) == 0) {
      return getMetaStruct<OpenDDS::DCPS::ReaderProxy_t>().getValue(ser, field + 12);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::ReaderProxy_t*>(0))) {
        throw std::runtime_error("Field 'readerProxy' could not be skipped");
      }
    }
    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
      return getMetaStruct<OpenDDS::DCPS::ContentFilterProperty_t>().getValue(ser, field + 22);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::ContentFilterProperty_t*>(0))) {
        throw std::runtime_error("Field 'contentFilterProperty' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DiscoveredReaderData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
      return make_struct_cmp(&T::ddsSubscriptionData, getMetaStruct<DDS::SubscriptionBuiltinTopicData>().create_qc_comparator(field + 20), next);
    }
    if (std::strncmp(field, "readerProxy.", 12) == 0) {
      return make_struct_cmp(&T::readerProxy, getMetaStruct<OpenDDS::DCPS::ReaderProxy_t>().create_qc_comparator(field + 12), next);
    }
    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
      return make_struct_cmp(&T::contentFilterProperty, getMetaStruct<OpenDDS::DCPS::ContentFilterProperty_t>().create_qc_comparator(field + 22), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsSubscriptionData", "readerProxy", "contentFilterProperty", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsSubscriptionData") == 0) {
      return &static_cast<const T*>(stru)->ddsSubscriptionData;
    }
    if (std::strcmp(field, "readerProxy") == 0) {
      return &static_cast<const T*>(stru)->readerProxy;
    }
    if (std::strcmp(field, "contentFilterProperty") == 0) {
      return &static_cast<const T*>(stru)->contentFilterProperty;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsSubscriptionData") == 0) {
      static_cast<T*>(lhs)->ddsSubscriptionData = *static_cast<const DDS::SubscriptionBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerProxy") == 0) {
      static_cast<T*>(lhs)->readerProxy = *static_cast<const OpenDDS::DCPS::ReaderProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "contentFilterProperty") == 0) {
      static_cast<T*>(lhs)->contentFilterProperty = *static_cast<const OpenDDS::DCPS::ContentFilterProperty_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DiscoveredReaderData>()
{
  static MetaStructImpl<OpenDDS::DCPS::DiscoveredReaderData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DiscoveredReaderData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DiscoveredReaderData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DiscoveredReaderData */


/* Begin STRUCT: WriterProxy_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::WriterProxy_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.remoteWriterGuid, size, padding);
  gen_find_size(stru.allLocators, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::WriterProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.remoteWriterGuid)
    && (strm << stru.allLocators);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::WriterProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.remoteWriterGuid)
    && (strm >> stru.allLocators);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::WriterProxy_t> : MetaStruct {
  typedef OpenDDS::DCPS::WriterProxy_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::WriterProxy_t& typed = *static_cast<const OpenDDS::DCPS::WriterProxy_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.remoteWriterGuid, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 17);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'remoteWriterGuid' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::WriterProxy_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
      return make_struct_cmp(&T::remoteWriterGuid, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"remoteWriterGuid", "allLocators", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "remoteWriterGuid") == 0) {
      return &static_cast<const T*>(stru)->remoteWriterGuid;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      return &static_cast<const T*>(stru)->allLocators;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "remoteWriterGuid") == 0) {
      static_cast<T*>(lhs)->remoteWriterGuid = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "allLocators") == 0) {
      static_cast<T*>(lhs)->allLocators = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::WriterProxy_t>()
{
  static MetaStructImpl<OpenDDS::DCPS::WriterProxy_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::WriterProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::WriterProxy_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: WriterProxy_t */


/* Begin STRUCT: DiscoveredWriterData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::DCPS::DiscoveredWriterData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsPublicationData, size, padding);
  gen_find_size(stru.writerProxy, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::DCPS::DiscoveredWriterData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsPublicationData)
    && (strm << stru.writerProxy);
}

bool operator>>(Serializer& strm, OpenDDS::DCPS::DiscoveredWriterData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsPublicationData)
    && (strm >> stru.writerProxy);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::DCPS::DiscoveredWriterData> : MetaStruct {
  typedef OpenDDS::DCPS::DiscoveredWriterData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::DCPS::DiscoveredWriterData& typed = *static_cast<const OpenDDS::DCPS::DiscoveredWriterData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
      return getMetaStruct<DDS::PublicationBuiltinTopicData>().getValue(&typed.ddsPublicationData, field + 19);
    }
    if (std::strncmp(field, "writerProxy.", 12) == 0) {
      return getMetaStruct<OpenDDS::DCPS::WriterProxy_t>().getValue(&typed.writerProxy, field + 12);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
      return getMetaStruct<DDS::PublicationBuiltinTopicData>().getValue(ser, field + 19);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::PublicationBuiltinTopicData*>(0))) {
        throw std::runtime_error("Field 'ddsPublicationData' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerProxy.", 12) == 0) {
      return getMetaStruct<OpenDDS::DCPS::WriterProxy_t>().getValue(ser, field + 12);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::WriterProxy_t*>(0))) {
        throw std::runtime_error("Field 'writerProxy' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DiscoveredWriterData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
      return make_struct_cmp(&T::ddsPublicationData, getMetaStruct<DDS::PublicationBuiltinTopicData>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "writerProxy.", 12) == 0) {
      return make_struct_cmp(&T::writerProxy, getMetaStruct<OpenDDS::DCPS::WriterProxy_t>().create_qc_comparator(field + 12), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsPublicationData", "writerProxy", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsPublicationData") == 0) {
      return &static_cast<const T*>(stru)->ddsPublicationData;
    }
    if (std::strcmp(field, "writerProxy") == 0) {
      return &static_cast<const T*>(stru)->writerProxy;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsPublicationData") == 0) {
      static_cast<T*>(lhs)->ddsPublicationData = *static_cast<const DDS::PublicationBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerProxy") == 0) {
      static_cast<T*>(lhs)->writerProxy = *static_cast<const OpenDDS::DCPS::WriterProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::DCPS::DiscoveredWriterData>()
{
  static MetaStructImpl<OpenDDS::DCPS::DiscoveredWriterData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DiscoveredWriterData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::DCPS::DiscoveredWriterData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DiscoveredWriterData */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */
