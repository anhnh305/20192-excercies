/* Generated by /Users/thiennd/Desktop/study-documents/20192/20192-excercies/DistributedSystem/OpenDDS-3.14/bin/opendds_idl version 3.14 (ACE version 6.2a_p17) running on input file RtpsCore.idl */
#include "RtpsCoreTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/PoolAllocator.h"
#include "dds/DdsDcpsCoreTypeSupportImpl.h"
#include "dds/DdsDcpsGuidTypeSupportImpl.h"
#include "dds/DdsDcpsInfoUtilsTypeSupportImpl.h"


/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */

/* End MODULE: CORBA */


/* Begin MODULE: CORBA */



/* Begin TYPEDEF: LongSeq */


/* End TYPEDEF: LongSeq */

/* End MODULE: CORBA */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: StringSeq */


/* End TYPEDEF: StringSeq */


/* Begin TYPEDEF: InstanceHandle_t */


/* End TYPEDEF: InstanceHandle_t */


/* Begin TYPEDEF: BuiltinTopicKeyValue */


/* End TYPEDEF: BuiltinTopicKeyValue */


/* Begin TYPEDEF: InstanceHandleSeq */


/* End TYPEDEF: InstanceHandleSeq */


/* Begin TYPEDEF: QosPolicyId_t */


/* End TYPEDEF: QosPolicyId_t */


/* Begin STRUCT: QosPolicyCount */


/* End STRUCT: QosPolicyCount */


/* Begin TYPEDEF: QosPolicyCountSeq */


/* End TYPEDEF: QosPolicyCountSeq */


/* Begin TYPEDEF: OctetSeq */


/* End TYPEDEF: OctetSeq */


/* Begin STRUCT: Duration_t */


/* End STRUCT: Duration_t */


/* Begin CONST: DURATION_INFINITE_SEC */


/* End CONST: DURATION_INFINITE_SEC */


/* Begin CONST: DURATION_INFINITE_NSEC */


/* End CONST: DURATION_INFINITE_NSEC */


/* Begin CONST: DURATION_ZERO_SEC */


/* End CONST: DURATION_ZERO_SEC */


/* Begin CONST: DURATION_ZERO_NSEC */


/* End CONST: DURATION_ZERO_NSEC */


/* Begin STRUCT: Property_t */


/* End STRUCT: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: BinaryProperty_t */


/* End STRUCT: BinaryProperty_t */


/* Begin TYPEDEF: BinaryPropertySeq */


/* End TYPEDEF: BinaryPropertySeq */


/* Begin STRUCT: PropertyQosPolicy */


/* End STRUCT: PropertyQosPolicy */


/* Begin STRUCT: UserDataQosPolicy */


/* End STRUCT: UserDataQosPolicy */


/* Begin STRUCT: GroupDataQosPolicy */


/* End STRUCT: GroupDataQosPolicy */


/* Begin STRUCT: TopicDataQosPolicy */


/* End STRUCT: TopicDataQosPolicy */


/* Begin STRUCT: PartitionQosPolicy */


/* End STRUCT: PartitionQosPolicy */


/* Begin ENUM: HistoryQosPolicyKind */


/* End ENUM: HistoryQosPolicyKind */


/* Begin ENUM: DurabilityQosPolicyKind */


/* End ENUM: DurabilityQosPolicyKind */


/* Begin STRUCT: DurabilityQosPolicy */


/* End STRUCT: DurabilityQosPolicy */


/* Begin STRUCT: DurabilityServiceQosPolicy */


/* End STRUCT: DurabilityServiceQosPolicy */


/* Begin STRUCT: DeadlineQosPolicy */


/* End STRUCT: DeadlineQosPolicy */


/* Begin STRUCT: LatencyBudgetQosPolicy */


/* End STRUCT: LatencyBudgetQosPolicy */


/* Begin ENUM: LivelinessQosPolicyKind */


/* End ENUM: LivelinessQosPolicyKind */


/* Begin STRUCT: LivelinessQosPolicy */


/* End STRUCT: LivelinessQosPolicy */


/* Begin ENUM: ReliabilityQosPolicyKind */


/* End ENUM: ReliabilityQosPolicyKind */


/* Begin STRUCT: ReliabilityQosPolicy */


/* End STRUCT: ReliabilityQosPolicy */


/* Begin ENUM: DestinationOrderQosPolicyKind */


/* End ENUM: DestinationOrderQosPolicyKind */


/* Begin STRUCT: DestinationOrderQosPolicy */


/* End STRUCT: DestinationOrderQosPolicy */


/* Begin STRUCT: HistoryQosPolicy */


/* End STRUCT: HistoryQosPolicy */


/* Begin STRUCT: ResourceLimitsQosPolicy */


/* End STRUCT: ResourceLimitsQosPolicy */


/* Begin STRUCT: TransportPriorityQosPolicy */


/* End STRUCT: TransportPriorityQosPolicy */


/* Begin STRUCT: LifespanQosPolicy */


/* End STRUCT: LifespanQosPolicy */


/* Begin ENUM: OwnershipQosPolicyKind */


/* End ENUM: OwnershipQosPolicyKind */


/* Begin STRUCT: OwnershipQosPolicy */


/* End STRUCT: OwnershipQosPolicy */


/* Begin STRUCT: OwnershipStrengthQosPolicy */


/* End STRUCT: OwnershipStrengthQosPolicy */


/* Begin ENUM: PresentationQosPolicyAccessScopeKind */


/* End ENUM: PresentationQosPolicyAccessScopeKind */


/* Begin STRUCT: PresentationQosPolicy */


/* End STRUCT: PresentationQosPolicy */


/* Begin STRUCT: TimeBasedFilterQosPolicy */


/* End STRUCT: TimeBasedFilterQosPolicy */


/* Begin STRUCT: TopicQos */


/* End STRUCT: TopicQos */


/* Begin STRUCT: WriterDataLifecycleQosPolicy */


/* End STRUCT: WriterDataLifecycleQosPolicy */


/* Begin STRUCT: DataWriterQos */


/* End STRUCT: DataWriterQos */


/* Begin STRUCT: EntityFactoryQosPolicy */


/* End STRUCT: EntityFactoryQosPolicy */


/* Begin STRUCT: PublisherQos */


/* End STRUCT: PublisherQos */


/* Begin STRUCT: ReaderDataLifecycleQosPolicy */


/* End STRUCT: ReaderDataLifecycleQosPolicy */


/* Begin STRUCT: DataReaderQos */


/* End STRUCT: DataReaderQos */


/* Begin STRUCT: SubscriberQos */


/* End STRUCT: SubscriberQos */


/* Begin STRUCT: DomainParticipantFactoryQos */


/* End STRUCT: DomainParticipantFactoryQos */


/* Begin STRUCT: DomainParticipantQos */


/* End STRUCT: DomainParticipantQos */


/* Begin STRUCT: BuiltinTopicKey_t */


/* End STRUCT: BuiltinTopicKey_t */


/* Begin STRUCT: ParticipantBuiltinTopicData */


/* End STRUCT: ParticipantBuiltinTopicData */


/* Begin STRUCT: PublicationBuiltinTopicData */


/* End STRUCT: PublicationBuiltinTopicData */


/* Begin STRUCT: SubscriptionBuiltinTopicData */


/* End STRUCT: SubscriptionBuiltinTopicData */


/* Begin STRUCT: TopicBuiltinTopicData */


/* End STRUCT: TopicBuiltinTopicData */


/* Begin TYPEDEF: SampleStateKind */


/* End TYPEDEF: SampleStateKind */


/* Begin CONST: READ_SAMPLE_STATE */


/* End CONST: READ_SAMPLE_STATE */


/* Begin CONST: NOT_READ_SAMPLE_STATE */


/* End CONST: NOT_READ_SAMPLE_STATE */


/* Begin TYPEDEF: SampleStateMask */


/* End TYPEDEF: SampleStateMask */


/* Begin CONST: ANY_SAMPLE_STATE */


/* End CONST: ANY_SAMPLE_STATE */


/* Begin TYPEDEF: ViewStateKind */


/* End TYPEDEF: ViewStateKind */


/* Begin CONST: NEW_VIEW_STATE */


/* End CONST: NEW_VIEW_STATE */


/* Begin CONST: NOT_NEW_VIEW_STATE */


/* End CONST: NOT_NEW_VIEW_STATE */


/* Begin TYPEDEF: ViewStateMask */


/* End TYPEDEF: ViewStateMask */


/* Begin CONST: ANY_VIEW_STATE */


/* End CONST: ANY_VIEW_STATE */


/* Begin TYPEDEF: InstanceStateKind */


/* End TYPEDEF: InstanceStateKind */


/* Begin CONST: ALIVE_INSTANCE_STATE */


/* End CONST: ALIVE_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */


/* Begin TYPEDEF: InstanceStateMask */


/* End TYPEDEF: InstanceStateMask */


/* Begin CONST: ANY_INSTANCE_STATE */


/* End CONST: ANY_INSTANCE_STATE */


/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */


/* End CONST: NOT_ALIVE_INSTANCE_STATE */


/* Begin STRUCT: Time_t */


/* End STRUCT: Time_t */


/* Begin CONST: TIME_INVALID_SEC */


/* End CONST: TIME_INVALID_SEC */


/* Begin CONST: TIME_INVALID_NSEC */


/* End CONST: TIME_INVALID_NSEC */


/* Begin STRUCT: SampleInfo */


/* End STRUCT: SampleInfo */


/* Begin TYPEDEF: SampleInfoSeq */


/* End TYPEDEF: SampleInfoSeq */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: ParticipantLocation */


/* End TYPEDEF: ParticipantLocation */


/* Begin TYPEDEF: OctetGuidArray16 */


/* End TYPEDEF: OctetGuidArray16 */


/* Begin CONST: LOCATION_LOCAL */


/* End CONST: LOCATION_LOCAL */


/* Begin CONST: LOCATION_ICE */


/* End CONST: LOCATION_ICE */


/* Begin CONST: LOCATION_RELAY */


/* End CONST: LOCATION_RELAY */


/* Begin STRUCT: ParticipantLocationBuiltinTopicData */


/* End STRUCT: ParticipantLocationBuiltinTopicData */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: GuidVendorId_t */


/* End TYPEDEF: GuidVendorId_t */


/* Begin TYPEDEF: GuidPrefix_t */


/* End TYPEDEF: GuidPrefix_t */


/* Begin TYPEDEF: EntityKey_t */


/* End TYPEDEF: EntityKey_t */


/* Begin STRUCT: EntityId_t */


/* End STRUCT: EntityId_t */


/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */


/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */


/* End CONST: ENTITYKIND_BUILTIN_TOPIC */


/* Begin CONST: ENTITYKIND_USER_UNKNOWN */


/* End CONST: ENTITYKIND_USER_UNKNOWN */


/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */


/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */


/* End CONST: ENTITYKIND_USER_READER_NO_KEY */


/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */


/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */


/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */


/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */


/* End CONST: ENTITYKIND_OPENDDS_TOPIC */


/* Begin CONST: ENTITYKIND_OPENDDS_USER */


/* End CONST: ENTITYKIND_OPENDDS_USER */


/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */


/* Begin STRUCT: GUID_t */


/* End STRUCT: GUID_t */


/* Begin TYPEDEF: GUIDSeq */


/* End TYPEDEF: GUIDSeq */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: DCPS */



/* Begin TYPEDEF: RepoId */


/* End TYPEDEF: RepoId */


/* Begin TYPEDEF: TransportBLOB */


/* End TYPEDEF: TransportBLOB */


/* Begin STRUCT: TransportLocator */


/* End STRUCT: TransportLocator */


/* Begin TYPEDEF: TransportLocatorSeq */


/* End TYPEDEF: TransportLocatorSeq */


/* Begin STRUCT: IncompatibleQosStatus */


/* End STRUCT: IncompatibleQosStatus */


/* Begin STRUCT: AddDomainStatus */


/* End STRUCT: AddDomainStatus */


/* Begin ENUM: TopicStatus */


/* End ENUM: TopicStatus */


/* Begin STRUCT: WriterAssociation */


/* End STRUCT: WriterAssociation */


/* Begin STRUCT: ReaderAssociation */


/* End STRUCT: ReaderAssociation */


/* Begin TYPEDEF: WriterIdSeq */


/* End TYPEDEF: WriterIdSeq */


/* Begin TYPEDEF: ReaderIdSeq */


/* End TYPEDEF: ReaderIdSeq */


/* Begin TYPEDEF: OctetArray16 */


/* End TYPEDEF: OctetArray16 */


/* Begin STRUCT: Locator_t */


/* End STRUCT: Locator_t */


/* Begin TYPEDEF: LocatorSeq */


/* End TYPEDEF: LocatorSeq */


/* Begin TYPEDEF: String256 */


/* End TYPEDEF: String256 */


/* Begin STRUCT: ContentFilterProperty_t */


/* End STRUCT: ContentFilterProperty_t */


/* Begin STRUCT: ReaderProxy_t */


/* End STRUCT: ReaderProxy_t */


/* Begin STRUCT: DiscoveredReaderData */


/* End STRUCT: DiscoveredReaderData */


/* Begin STRUCT: WriterProxy_t */


/* End STRUCT: WriterProxy_t */


/* Begin STRUCT: DiscoveredWriterData */


/* End STRUCT: DiscoveredWriterData */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: DDS */



/* Begin INTERFACE-FWD: Condition */


/* End INTERFACE-FWD: Condition */


/* Begin TYPEDEF: ConditionSeq */


/* End TYPEDEF: ConditionSeq */

/* End MODULE: DDS */


/* Begin MODULE: DDS */



/* Begin TYPEDEF: DomainId_t */


/* End TYPEDEF: DomainId_t */


/* Begin TYPEDEF: ReturnCode_t */


/* End TYPEDEF: ReturnCode_t */


/* Begin CONST: HANDLE_NIL */


/* End CONST: HANDLE_NIL */


/* Begin CONST: LENGTH_UNLIMITED */


/* End CONST: LENGTH_UNLIMITED */


/* Begin CONST: RETCODE_OK */


/* End CONST: RETCODE_OK */


/* Begin CONST: RETCODE_ERROR */


/* End CONST: RETCODE_ERROR */


/* Begin CONST: RETCODE_UNSUPPORTED */


/* End CONST: RETCODE_UNSUPPORTED */


/* Begin CONST: RETCODE_BAD_PARAMETER */


/* End CONST: RETCODE_BAD_PARAMETER */


/* Begin CONST: RETCODE_PRECONDITION_NOT_MET */


/* End CONST: RETCODE_PRECONDITION_NOT_MET */


/* Begin CONST: RETCODE_OUT_OF_RESOURCES */


/* End CONST: RETCODE_OUT_OF_RESOURCES */


/* Begin CONST: RETCODE_NOT_ENABLED */


/* End CONST: RETCODE_NOT_ENABLED */


/* Begin CONST: RETCODE_IMMUTABLE_POLICY */


/* End CONST: RETCODE_IMMUTABLE_POLICY */


/* Begin CONST: RETCODE_INCONSISTENT_POLICY */


/* End CONST: RETCODE_INCONSISTENT_POLICY */


/* Begin CONST: RETCODE_ALREADY_DELETED */


/* End CONST: RETCODE_ALREADY_DELETED */


/* Begin CONST: RETCODE_TIMEOUT */


/* End CONST: RETCODE_TIMEOUT */


/* Begin CONST: RETCODE_NO_DATA */


/* End CONST: RETCODE_NO_DATA */


/* Begin CONST: RETCODE_ILLEGAL_OPERATION */


/* End CONST: RETCODE_ILLEGAL_OPERATION */


/* Begin TYPEDEF: StatusKind */


/* End TYPEDEF: StatusKind */


/* Begin TYPEDEF: StatusMask */


/* End TYPEDEF: StatusMask */


/* Begin CONST: INCONSISTENT_TOPIC_STATUS */


/* End CONST: INCONSISTENT_TOPIC_STATUS */


/* Begin CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* End CONST: OFFERED_DEADLINE_MISSED_STATUS */


/* Begin CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* End CONST: REQUESTED_DEADLINE_MISSED_STATUS */


/* Begin CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: OFFERED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* End CONST: REQUESTED_INCOMPATIBLE_QOS_STATUS */


/* Begin CONST: SAMPLE_LOST_STATUS */


/* End CONST: SAMPLE_LOST_STATUS */


/* Begin CONST: SAMPLE_REJECTED_STATUS */


/* End CONST: SAMPLE_REJECTED_STATUS */


/* Begin CONST: DATA_ON_READERS_STATUS */


/* End CONST: DATA_ON_READERS_STATUS */


/* Begin CONST: DATA_AVAILABLE_STATUS */


/* End CONST: DATA_AVAILABLE_STATUS */


/* Begin CONST: LIVELINESS_LOST_STATUS */


/* End CONST: LIVELINESS_LOST_STATUS */


/* Begin CONST: LIVELINESS_CHANGED_STATUS */


/* End CONST: LIVELINESS_CHANGED_STATUS */


/* Begin CONST: PUBLICATION_MATCHED_STATUS */


/* End CONST: PUBLICATION_MATCHED_STATUS */


/* Begin CONST: SUBSCRIPTION_MATCHED_STATUS */


/* End CONST: SUBSCRIPTION_MATCHED_STATUS */


/* Begin STRUCT: InconsistentTopicStatus */


/* End STRUCT: InconsistentTopicStatus */


/* Begin STRUCT: SampleLostStatus */


/* End STRUCT: SampleLostStatus */


/* Begin ENUM: SampleRejectedStatusKind */


/* End ENUM: SampleRejectedStatusKind */


/* Begin STRUCT: SampleRejectedStatus */


/* End STRUCT: SampleRejectedStatus */


/* Begin STRUCT: LivelinessLostStatus */


/* End STRUCT: LivelinessLostStatus */


/* Begin STRUCT: LivelinessChangedStatus */


/* End STRUCT: LivelinessChangedStatus */


/* Begin STRUCT: OfferedDeadlineMissedStatus */


/* End STRUCT: OfferedDeadlineMissedStatus */


/* Begin STRUCT: RequestedDeadlineMissedStatus */


/* End STRUCT: RequestedDeadlineMissedStatus */


/* Begin STRUCT: OfferedIncompatibleQosStatus */


/* End STRUCT: OfferedIncompatibleQosStatus */


/* Begin STRUCT: RequestedIncompatibleQosStatus */


/* End STRUCT: RequestedIncompatibleQosStatus */


/* Begin STRUCT: PublicationMatchedStatus */


/* End STRUCT: PublicationMatchedStatus */


/* Begin STRUCT: SubscriptionMatchedStatus */


/* End STRUCT: SubscriptionMatchedStatus */


/* Begin INTERFACE-FWD: Listener */


/* End INTERFACE-FWD: Listener */


/* Begin INTERFACE-FWD: Entity */


/* End INTERFACE-FWD: Entity */


/* Begin INTERFACE: Listener */


/* End INTERFACE: Listener */


/* Begin INTERFACE: Condition */


/* End INTERFACE: Condition */


/* Begin INTERFACE: WaitSetInterf */


/* End INTERFACE: WaitSetInterf */


/* Begin INTERFACE: GuardConditionInterf */


/* End INTERFACE: GuardConditionInterf */


/* Begin INTERFACE: StatusCondition */


/* End INTERFACE: StatusCondition */


/* Begin CONST: USERDATA_QOS_POLICY_NAME */


/* End CONST: USERDATA_QOS_POLICY_NAME */


/* Begin CONST: DURABILITY_QOS_POLICY_NAME */


/* End CONST: DURABILITY_QOS_POLICY_NAME */


/* Begin CONST: PRESENTATION_QOS_POLICY_NAME */


/* End CONST: PRESENTATION_QOS_POLICY_NAME */


/* Begin CONST: DEADLINE_QOS_POLICY_NAME */


/* End CONST: DEADLINE_QOS_POLICY_NAME */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* End CONST: LATENCYBUDGET_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIP_QOS_POLICY_NAME */


/* End CONST: OWNERSHIP_QOS_POLICY_NAME */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_NAME */


/* Begin CONST: LIVELINESS_QOS_POLICY_NAME */


/* End CONST: LIVELINESS_QOS_POLICY_NAME */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_NAME */


/* Begin CONST: PARTITION_QOS_POLICY_NAME */


/* End CONST: PARTITION_QOS_POLICY_NAME */


/* Begin CONST: RELIABILITY_QOS_POLICY_NAME */


/* End CONST: RELIABILITY_QOS_POLICY_NAME */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* End CONST: DESTINATIONORDER_QOS_POLICY_NAME */


/* Begin CONST: HISTORY_QOS_POLICY_NAME */


/* End CONST: HISTORY_QOS_POLICY_NAME */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* End CONST: RESOURCELIMITS_QOS_POLICY_NAME */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* End CONST: ENTITYFACTORY_QOS_POLICY_NAME */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_NAME */


/* Begin CONST: TOPICDATA_QOS_POLICY_NAME */


/* End CONST: TOPICDATA_QOS_POLICY_NAME */


/* Begin CONST: GROUPDATA_QOS_POLICY_NAME */


/* End CONST: GROUPDATA_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_NAME */


/* Begin CONST: LIFESPAN_QOS_POLICY_NAME */


/* End CONST: LIFESPAN_QOS_POLICY_NAME */


/* Begin CONST: DURABILITYSERVICE_POLICY_NAME */


/* End CONST: DURABILITYSERVICE_POLICY_NAME */


/* Begin CONST: INVALID_QOS_POLICY_ID */


/* End CONST: INVALID_QOS_POLICY_ID */


/* Begin CONST: USERDATA_QOS_POLICY_ID */


/* End CONST: USERDATA_QOS_POLICY_ID */


/* Begin CONST: DURABILITY_QOS_POLICY_ID */


/* End CONST: DURABILITY_QOS_POLICY_ID */


/* Begin CONST: PRESENTATION_QOS_POLICY_ID */


/* End CONST: PRESENTATION_QOS_POLICY_ID */


/* Begin CONST: DEADLINE_QOS_POLICY_ID */


/* End CONST: DEADLINE_QOS_POLICY_ID */


/* Begin CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* End CONST: LATENCYBUDGET_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIP_QOS_POLICY_ID */


/* End CONST: OWNERSHIP_QOS_POLICY_ID */


/* Begin CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* End CONST: OWNERSHIPSTRENGTH_QOS_POLICY_ID */


/* Begin CONST: LIVELINESS_QOS_POLICY_ID */


/* End CONST: LIVELINESS_QOS_POLICY_ID */


/* Begin CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* End CONST: TIMEBASEDFILTER_QOS_POLICY_ID */


/* Begin CONST: PARTITION_QOS_POLICY_ID */


/* End CONST: PARTITION_QOS_POLICY_ID */


/* Begin CONST: RELIABILITY_QOS_POLICY_ID */


/* End CONST: RELIABILITY_QOS_POLICY_ID */


/* Begin CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* End CONST: DESTINATIONORDER_QOS_POLICY_ID */


/* Begin CONST: HISTORY_QOS_POLICY_ID */


/* End CONST: HISTORY_QOS_POLICY_ID */


/* Begin CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* End CONST: RESOURCELIMITS_QOS_POLICY_ID */


/* Begin CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* End CONST: ENTITYFACTORY_QOS_POLICY_ID */


/* Begin CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: WRITERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* End CONST: READERDATALIFECYCLE_QOS_POLICY_ID */


/* Begin CONST: TOPICDATA_QOS_POLICY_ID */


/* End CONST: TOPICDATA_QOS_POLICY_ID */


/* Begin CONST: GROUPDATA_QOS_POLICY_ID */


/* End CONST: GROUPDATA_QOS_POLICY_ID */


/* Begin CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* End CONST: TRANSPORTPRIORITY_QOS_POLICY_ID */


/* Begin CONST: LIFESPAN_QOS_POLICY_ID */


/* End CONST: LIFESPAN_QOS_POLICY_ID */


/* Begin CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* End CONST: DURABILITYSERVICE_QOS_POLICY_ID */


/* Begin INTERFACE: Entity */


/* End INTERFACE: Entity */

/* End MODULE: DDS */


/* Begin MODULE: OpenDDS */



/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_NAME */


/* Begin CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* End CONST: TRANSPORTTYPE_QOS_POLICY_ID */


/* Begin CONST: MAX_USER_DOMAINID */


/* End CONST: MAX_USER_DOMAINID */


/* Begin MODULE: DCPS */



/* Begin CONST: ALL_STATUS_MASK */


/* End CONST: ALL_STATUS_MASK */


/* Begin CONST: NO_STATUS_MASK */


/* End CONST: NO_STATUS_MASK */


/* Begin CONST: DEFAULT_STATUS_MASK */


/* End CONST: DEFAULT_STATUS_MASK */

/* End MODULE: DCPS */

/* End MODULE: OpenDDS */


/* Begin MODULE: OpenDDS */



/* Begin MODULE: RTPS */



/* Begin TYPEDEF: OctetArray2 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OctetArray2_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 2 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 2);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OctetArray2_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 2);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::OctetArray2_forany*)
{
  ACE_UNUSED_ARG(ser);
  return ser.skip(static_cast<ACE_UINT16>(2), 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray2 */


/* Begin TYPEDEF: OctetArray4 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OctetArray4_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 4 * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_octet_array(arr.in(), 4);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OctetArray4_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_octet_array(arr.out(), 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::OctetArray4_forany*)
{
  ACE_UNUSED_ARG(ser);
  return ser.skip(static_cast<ACE_UINT16>(4), 1);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: OctetArray4 */


/* Begin TYPEDEF: FilterSignature_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterSignature_t_forany& arr, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(arr);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += 4 * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.write_long_array(arr.in(), 4);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterSignature_t_forany& arr)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(arr);
  return strm.read_long_array(arr.out(), 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterSignature_t_forany*)
{
  ACE_UNUSED_ARG(ser);
  return ser.skip(static_cast<ACE_UINT16>(4), 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterSignature_t */


/* Begin TYPEDEF: FilterResult_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterResult_t& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterResult_t& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterResult_t*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  return ser.skip(static_cast<ACE_UINT16>(length), 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterResult_t */


/* Begin TYPEDEF: FilterSignatureSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FilterSignatureSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp_var = OpenDDS::RTPS::FilterSignature_t_dup(seq[i]);
    OpenDDS::RTPS::FilterSignature_t_forany tmp = tmp_var.inout();
    gen_find_size(tmp, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp_var = OpenDDS::RTPS::FilterSignature_t_dup(seq[i]);
    OpenDDS::RTPS::FilterSignature_t_forany tmp = tmp_var.inout();
    if (!(strm << tmp)) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FilterSignatureSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    OpenDDS::RTPS::FilterSignature_t_var tmp = OpenDDS::RTPS::FilterSignature_t_alloc();
    OpenDDS::RTPS::FilterSignature_t_forany fa = tmp.inout();
    if (!(strm >> fa)) {
      return false;
    }
    OpenDDS::RTPS::FilterSignature_t_copy(seq[i], tmp.in());
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::FilterSignatureSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterSignature_t_forany*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: FilterSignatureSeq */


/* Begin STRUCT: ContentFilterInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ContentFilterInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.filterResult, size, padding);
  gen_find_size(stru.filterSignatures, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.filterResult)
    && (strm << stru.filterSignatures);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ContentFilterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.filterResult)
    && (strm >> stru.filterSignatures);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::ContentFilterInfo_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ContentFilterInfo_t& typed = *static_cast<const OpenDDS::RTPS::ContentFilterInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterResult_t*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::FilterSignatureSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ContentFilterInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"filterResult", "filterSignatures", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "filterResult") == 0) {
      return &static_cast<const T*>(stru)->filterResult;
    }
    if (std::strcmp(field, "filterSignatures") == 0) {
      return &static_cast<const T*>(stru)->filterSignatures;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "filterResult") == 0) {
      static_cast<T*>(lhs)->filterResult = *static_cast<const OpenDDS::RTPS::FilterResult_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "filterSignatures") == 0) {
      static_cast<T*>(lhs)->filterSignatures = *static_cast<const OpenDDS::RTPS::FilterSignatureSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ContentFilterInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ContentFilterInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::ContentFilterInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ContentFilterInfo_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ContentFilterInfo_t */


/* Begin TYPEDEF: Property_t */


/* End TYPEDEF: Property_t */


/* Begin TYPEDEF: PropertySeq */


/* End TYPEDEF: PropertySeq */


/* Begin STRUCT: EntityName_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::EntityName_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.name.in()) + 1;
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.name.in());
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::EntityName_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.name.out());
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::EntityName_t> : MetaStruct {
  typedef OpenDDS::RTPS::EntityName_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::EntityName_t& typed = *static_cast<const OpenDDS::RTPS::EntityName_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "name") == 0) {
      return typed.name.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'name' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'name' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'name' contents could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::EntityName_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "name") == 0) {
      return make_field_cmp(&T::name, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"name", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "name") == 0) {
      return &static_cast<const T*>(stru)->name;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "name") == 0) {
      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "name") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::EntityName_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::EntityName_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::EntityName_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::EntityName_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::EntityName_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: EntityName_t */


/* Begin STRUCT: Count_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Count_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Count_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Count_t> : MetaStruct {
  typedef OpenDDS::RTPS::Count_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Count_t& typed = *static_cast<const OpenDDS::RTPS::Count_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Count_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Count_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Count_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Count_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::Count_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Count_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Count_t */


/* Begin STRUCT: SequenceNumber_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SequenceNumber_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.high);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.low);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.high)
    && (strm << stru.low);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SequenceNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.high)
    && (strm >> stru.low);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t> : MetaStruct {
  typedef OpenDDS::RTPS::SequenceNumber_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SequenceNumber_t& typed = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "high") == 0) {
      return typed.high;
    }
    if (std::strcmp(field, "low") == 0) {
      return typed.low;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "high") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'high' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'high' could not be skipped");
      }
    }
    if (std::strcmp(field, "low") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'low' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'low' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SequenceNumber_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "high") == 0) {
      return make_field_cmp(&T::high, next);
    }
    if (std::strcmp(field, "low") == 0) {
      return make_field_cmp(&T::low, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"high", "low", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "high") == 0) {
      return &static_cast<const T*>(stru)->high;
    }
    if (std::strcmp(field, "low") == 0) {
      return &static_cast<const T*>(stru)->low;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "high") == 0) {
      static_cast<T*>(lhs)->high = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "low") == 0) {
      static_cast<T*>(lhs)->low = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "high") == 0) {
      return static_cast<const T*>(lhs)->high == static_cast<const T*>(rhs)->high;
    }
    if (std::strcmp(field, "low") == 0) {
      return static_cast<const T*>(lhs)->low == static_cast<const T*>(rhs)->low;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumber_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::SequenceNumber_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SequenceNumber_t */


/* Begin TYPEDEF: LongSeq8 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LongSeq8& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (length > 8) {
    return false;
  }
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  return strm.write_long_array(seq.get_buffer(), length);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LongSeq8& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  if (length == 0) {
    return true;
  }
  return strm.read_long_array(seq.get_buffer(), length);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::LongSeq8*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  return ser.skip(static_cast<ACE_UINT16>(length), 4);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LongSeq8 */


/* Begin STRUCT: SequenceNumberSet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SequenceNumberSet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 12 + 4 * ((stru.numBits + 31) / 32); // RTPS Custom
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm << stru.bitmapBase) && (strm << stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (stru.bitmap.length() < M) {
      return false;
    }
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm << stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SequenceNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm >> stru.bitmapBase) && (strm >> stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (M > 8) {
      return false;
    }
    stru.bitmap.length(M);
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm >> stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet> : MetaStruct {
  typedef OpenDDS::RTPS::SequenceNumberSet T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SequenceNumberSet& typed = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.bitmapBase, field + 11);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return typed.numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 11);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'bitmapBase' could not be skipped");
      }
    }
    if (std::strcmp(field, "numBits") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'numBits' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'numBits' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::LongSeq8*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SequenceNumberSet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return make_struct_cmp(&T::bitmapBase, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 11), next);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return make_field_cmp(&T::numBits, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"bitmapBase", "numBits", "bitmap", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bitmapBase") == 0) {
      return &static_cast<const T*>(stru)->bitmapBase;
    }
    if (std::strcmp(field, "numBits") == 0) {
      return &static_cast<const T*>(stru)->numBits;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      return &static_cast<const T*>(stru)->bitmap;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bitmapBase") == 0) {
      static_cast<T*>(lhs)->bitmapBase = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "numBits") == 0) {
      static_cast<T*>(lhs)->numBits = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      static_cast<T*>(lhs)->bitmap = *static_cast<const OpenDDS::RTPS::LongSeq8*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "numBits") == 0) {
      return static_cast<const T*>(lhs)->numBits == static_cast<const T*>(rhs)->numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SequenceNumberSet)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>()
{
  static MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::SequenceNumberSet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SequenceNumberSet */


/* Begin TYPEDEF: LocatorList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LocatorList& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (length > 8) {
    return false;
  }
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LocatorList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  if (length > seq.maximum()) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::LocatorList*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::Locator_t*>(0))) return false;
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: LocatorList */


/* Begin STRUCT: Time_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Time_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.seconds);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.fraction);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.seconds)
    && (strm << stru.fraction);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Time_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.seconds)
    && (strm >> stru.fraction);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Time_t> : MetaStruct {
  typedef OpenDDS::RTPS::Time_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Time_t& typed = *static_cast<const OpenDDS::RTPS::Time_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "seconds") == 0) {
      return typed.seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return typed.fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'seconds' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'seconds' could not be skipped");
      }
    }
    if (std::strcmp(field, "fraction") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fraction' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'fraction' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Time_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "seconds") == 0) {
      return make_field_cmp(&T::seconds, next);
    }
    if (std::strcmp(field, "fraction") == 0) {
      return make_field_cmp(&T::fraction, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"seconds", "fraction", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      return &static_cast<const T*>(stru)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return &static_cast<const T*>(stru)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "seconds") == 0) {
      static_cast<T*>(lhs)->seconds = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fraction") == 0) {
      static_cast<T*>(lhs)->fraction = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "seconds") == 0) {
      return static_cast<const T*>(lhs)->seconds == static_cast<const T*>(rhs)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return static_cast<const T*>(lhs)->fraction == static_cast<const T*>(rhs)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Time_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Time_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Time_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::Time_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Time_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Time_t */


/* Begin TYPEDEF: Timestamp_t */


/* End TYPEDEF: Timestamp_t */


/* Begin STRUCT: Duration_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Duration_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.seconds);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.fraction);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.seconds)
    && (strm << stru.fraction);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Duration_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.seconds)
    && (strm >> stru.fraction);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Duration_t> : MetaStruct {
  typedef OpenDDS::RTPS::Duration_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Duration_t& typed = *static_cast<const OpenDDS::RTPS::Duration_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "seconds") == 0) {
      return typed.seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return typed.fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Duration_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'seconds' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'seconds' could not be skipped");
      }
    }
    if (std::strcmp(field, "fraction") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fraction' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'fraction' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Duration_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "seconds") == 0) {
      return make_field_cmp(&T::seconds, next);
    }
    if (std::strcmp(field, "fraction") == 0) {
      return make_field_cmp(&T::fraction, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Duration_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"seconds", "fraction", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "seconds") == 0) {
      return &static_cast<const T*>(stru)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return &static_cast<const T*>(stru)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Duration_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "seconds") == 0) {
      static_cast<T*>(lhs)->seconds = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fraction") == 0) {
      static_cast<T*>(lhs)->fraction = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Duration_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "seconds") == 0) {
      return static_cast<const T*>(lhs)->seconds == static_cast<const T*>(rhs)->seconds;
    }
    if (std::strcmp(field, "fraction") == 0) {
      return static_cast<const T*>(lhs)->fraction == static_cast<const T*>(rhs)->fraction;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Duration_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Duration_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::Duration_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::Duration_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Duration_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Duration_t */


/* Begin CONST: LOCATOR_KIND_INVALID */


/* End CONST: LOCATOR_KIND_INVALID */


/* Begin CONST: LOCATOR_KIND_RESERVED */


/* End CONST: LOCATOR_KIND_RESERVED */


/* Begin CONST: LOCATOR_KIND_UDPv4 */


/* End CONST: LOCATOR_KIND_UDPv4 */


/* Begin CONST: LOCATOR_KIND_UDPv6 */


/* End CONST: LOCATOR_KIND_UDPv6 */


/* Begin CONST: LOCATOR_PORT_INVALID */


/* End CONST: LOCATOR_PORT_INVALID */


/* Begin STRUCT: LocatorUDPv4_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::LocatorUDPv4_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.address);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.port);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.address)
    && (strm << stru.port);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::LocatorUDPv4_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.address)
    && (strm >> stru.port);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t> : MetaStruct {
  typedef OpenDDS::RTPS::LocatorUDPv4_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::LocatorUDPv4_t& typed = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "address") == 0) {
      return typed.address;
    }
    if (std::strcmp(field, "port") == 0) {
      return typed.port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "address") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'address' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'address' could not be skipped");
      }
    }
    if (std::strcmp(field, "port") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'port' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'port' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::LocatorUDPv4_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "address") == 0) {
      return make_field_cmp(&T::address, next);
    }
    if (std::strcmp(field, "port") == 0) {
      return make_field_cmp(&T::port, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"address", "port", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "address") == 0) {
      return &static_cast<const T*>(stru)->address;
    }
    if (std::strcmp(field, "port") == 0) {
      return &static_cast<const T*>(stru)->port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "address") == 0) {
      static_cast<T*>(lhs)->address = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "port") == 0) {
      static_cast<T*>(lhs)->port = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "address") == 0) {
      return static_cast<const T*>(lhs)->address == static_cast<const T*>(rhs)->address;
    }
    if (std::strcmp(field, "port") == 0) {
      return static_cast<const T*>(lhs)->port == static_cast<const T*>(rhs)->port;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::LocatorUDPv4_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::LocatorUDPv4_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: LocatorUDPv4_t */


/* Begin STRUCT: TopicKind_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::TopicKind_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::TopicKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::TopicKind_t> : MetaStruct {
  typedef OpenDDS::RTPS::TopicKind_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::TopicKind_t& typed = *static_cast<const OpenDDS::RTPS::TopicKind_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::TopicKind_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::TopicKind_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::TopicKind_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::TopicKind_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::TopicKind_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::TopicKind_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: TopicKind_t */


/* Begin CONST: NO_KEY */


/* End CONST: NO_KEY */


/* Begin CONST: WITH_KEY */


/* End CONST: WITH_KEY */


/* Begin STRUCT: ReliabilityKind_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ReliabilityKind_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ReliabilityKind_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t> : MetaStruct {
  typedef OpenDDS::RTPS::ReliabilityKind_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ReliabilityKind_t& typed = *static_cast<const OpenDDS::RTPS::ReliabilityKind_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ReliabilityKind_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ReliabilityKind_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ReliabilityKind_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::ReliabilityKind_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ReliabilityKind_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ReliabilityKind_t */


/* Begin CONST: BEST_EFFORT */


/* End CONST: BEST_EFFORT */


/* Begin CONST: RELIABLE */


/* End CONST: RELIABLE */


/* Begin STRUCT: KeyHash_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::KeyHash_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::OctetArray16_forany stru_value(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.value));
  gen_find_size(stru_value, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::OctetArray16_forany stru_value(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.value));
  return (strm << stru_value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::KeyHash_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::OctetArray16_forany stru_value(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.value));
  return (strm >> stru_value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::KeyHash_t> : MetaStruct {
  typedef OpenDDS::RTPS::KeyHash_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::KeyHash_t& typed = *static_cast<const OpenDDS::RTPS::KeyHash_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::OctetArray16_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::KeyHash_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      OpenDDS::DCPS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->value;
      const OpenDDS::DCPS::OctetArray16* rhsArr = static_cast<const OpenDDS::DCPS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::KeyHash_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::KeyHash_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::KeyHash_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::KeyHash_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::KeyHash_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: KeyHash_t */


/* Begin STRUCT: StatusInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::StatusInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  gen_find_size(stru_value, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  return (strm << stru_value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::StatusInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_value(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.value));
  return (strm >> stru_value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::StatusInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::StatusInfo_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::StatusInfo_t& typed = *static_cast<const OpenDDS::RTPS::StatusInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray4_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::StatusInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      OpenDDS::RTPS::OctetArray4* lhsArr = &static_cast<T*>(lhs)->value;
      const OpenDDS::RTPS::OctetArray4* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray4*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::StatusInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::StatusInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::StatusInfo_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::StatusInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::StatusInfo_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: StatusInfo_t */


/* Begin STRUCT: ProtocolVersion_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ProtocolVersion_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.major));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.minor));
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << ACE_OutputCDR::from_octet(stru.major))
    && (strm << ACE_OutputCDR::from_octet(stru.minor));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ProtocolVersion_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.major))
    && (strm >> ACE_InputCDR::to_octet(stru.minor));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t> : MetaStruct {
  typedef OpenDDS::RTPS::ProtocolVersion_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ProtocolVersion_t& typed = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "major") == 0) {
      return typed.major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return typed.minor;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "major") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'major' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'major' could not be skipped");
      }
    }
    if (std::strcmp(field, "minor") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'minor' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'minor' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ProtocolVersion_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "major") == 0) {
      return make_field_cmp(&T::major, next);
    }
    if (std::strcmp(field, "minor") == 0) {
      return make_field_cmp(&T::minor, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"major", "minor", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "major") == 0) {
      return &static_cast<const T*>(stru)->major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return &static_cast<const T*>(stru)->minor;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "major") == 0) {
      static_cast<T*>(lhs)->major = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "minor") == 0) {
      static_cast<T*>(lhs)->minor = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "major") == 0) {
      return static_cast<const T*>(lhs)->major == static_cast<const T*>(rhs)->major;
    }
    if (std::strcmp(field, "minor") == 0) {
      return static_cast<const T*>(lhs)->minor == static_cast<const T*>(rhs)->minor;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ProtocolVersion_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::ProtocolVersion_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ProtocolVersion_t */


/* Begin STRUCT: VendorId_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::VendorId_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  gen_find_size(stru_vendorId, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  return (strm << stru_vendorId);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::VendorId_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray2_forany stru_vendorId(const_cast<OpenDDS::RTPS::OctetArray2_slice*>(stru.vendorId));
  return (strm >> stru_vendorId);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::VendorId_t> : MetaStruct {
  typedef OpenDDS::RTPS::VendorId_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::VendorId_t& typed = *static_cast<const OpenDDS::RTPS::VendorId_t*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray2_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::VendorId_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"vendorId", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "vendorId") == 0) {
      OpenDDS::RTPS::OctetArray2* lhsArr = &static_cast<T*>(lhs)->vendorId;
      const OpenDDS::RTPS::OctetArray2* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray2*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 2; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::VendorId_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::VendorId_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::VendorId_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::VendorId_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::VendorId_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: VendorId_t */


/* Begin TYPEDEF: IceAgentType_t */


/* End TYPEDEF: IceAgentType_t */


/* Begin CONST: ICE_FULL */


/* End CONST: ICE_FULL */


/* Begin CONST: ICE_LITE */


/* End CONST: ICE_LITE */


/* Begin STRUCT: IceGeneral_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::IceGeneral_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.key.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.agent_type);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.username.in()) + 1;
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.password.in()) + 1;
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::IceGeneral_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key.in())
    && (strm << stru.agent_type)
    && (strm << stru.username.in())
    && (strm << stru.password.in());
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::IceGeneral_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key.out())
    && (strm >> stru.agent_type)
    && (strm >> stru.username.out())
    && (strm >> stru.password.out());
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::IceGeneral_t> : MetaStruct {
  typedef OpenDDS::RTPS::IceGeneral_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::IceGeneral_t& typed = *static_cast<const OpenDDS::RTPS::IceGeneral_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "key") == 0) {
      return typed.key.in();
    }
    if (std::strcmp(field, "agent_type") == 0) {
      return typed.agent_type;
    }
    if (std::strcmp(field, "username") == 0) {
      return typed.username.in();
    }
    if (std::strcmp(field, "password") == 0) {
      return typed.password.in();
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceGeneral_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'key' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'key' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'key' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "agent_type") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'agent_type' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'agent_type' could not be skipped");
      }
    }
    if (std::strcmp(field, "username") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'username' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'username' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'username' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "password") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'password' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'password' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'password' contents could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::IceGeneral_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "key") == 0) {
      return make_field_cmp(&T::key, next);
    }
    if (std::strcmp(field, "agent_type") == 0) {
      return make_field_cmp(&T::agent_type, next);
    }
    if (std::strcmp(field, "username") == 0) {
      return make_field_cmp(&T::username, next);
    }
    if (std::strcmp(field, "password") == 0) {
      return make_field_cmp(&T::password, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceGeneral_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "agent_type", "username", "password", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "agent_type") == 0) {
      return &static_cast<const T*>(stru)->agent_type;
    }
    if (std::strcmp(field, "username") == 0) {
      return &static_cast<const T*>(stru)->username;
    }
    if (std::strcmp(field, "password") == 0) {
      return &static_cast<const T*>(stru)->password;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceGeneral_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "agent_type") == 0) {
      static_cast<T*>(lhs)->agent_type = *static_cast<const OpenDDS::RTPS::IceAgentType_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "username") == 0) {
      static_cast<T*>(lhs)->username = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "password") == 0) {
      static_cast<T*>(lhs)->password = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceGeneral_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "key") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->key.in(), static_cast<const T*>(rhs)->key.in());
    }
    if (std::strcmp(field, "agent_type") == 0) {
      return static_cast<const T*>(lhs)->agent_type == static_cast<const T*>(rhs)->agent_type;
    }
    if (std::strcmp(field, "username") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->username.in(), static_cast<const T*>(rhs)->username.in());
    }
    if (std::strcmp(field, "password") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->password.in(), static_cast<const T*>(rhs)->password.in());
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceGeneral_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::IceGeneral_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::IceGeneral_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::IceGeneral_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::IceGeneral_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: IceGeneral_t */


/* Begin TYPEDEF: IceCandidateType_t */


/* End TYPEDEF: IceCandidateType_t */


/* Begin CONST: ICE_HOST */


/* End CONST: ICE_HOST */


/* Begin CONST: ICE_SERVER_REFLEXIVE */


/* End CONST: ICE_SERVER_REFLEXIVE */


/* Begin CONST: ICE_PEER_REFLEXIVE */


/* End CONST: ICE_PEER_REFLEXIVE */


/* Begin CONST: ICE_RELAYED */


/* End CONST: ICE_RELAYED */


/* Begin STRUCT: IceCandidate_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::IceCandidate_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.key.in()) + 1;
  gen_find_size(stru.locator, size, padding);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.foundation.in()) + 1;
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.priority);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.type);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::IceCandidate_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.key.in())
    && (strm << stru.locator)
    && (strm << stru.foundation.in())
    && (strm << stru.priority)
    && (strm << stru.type);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::IceCandidate_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.key.out())
    && (strm >> stru.locator)
    && (strm >> stru.foundation.out())
    && (strm >> stru.priority)
    && (strm >> stru.type);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::IceCandidate_t> : MetaStruct {
  typedef OpenDDS::RTPS::IceCandidate_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::IceCandidate_t& typed = *static_cast<const OpenDDS::RTPS::IceCandidate_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "key") == 0) {
      return typed.key.in();
    }
    if (std::strncmp(field, "locator.", 8) == 0) {
      return getMetaStruct<OpenDDS::DCPS::Locator_t>().getValue(&typed.locator, field + 8);
    }
    if (std::strcmp(field, "foundation") == 0) {
      return typed.foundation.in();
    }
    if (std::strcmp(field, "priority") == 0) {
      return typed.priority;
    }
    if (std::strcmp(field, "type") == 0) {
      return typed.type;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceCandidate_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'key' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'key' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'key' contents could not be skipped");
      }
    }
    if (std::strncmp(field, "locator.", 8) == 0) {
      return getMetaStruct<OpenDDS::DCPS::Locator_t>().getValue(ser, field + 8);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::Locator_t*>(0))) {
        throw std::runtime_error("Field 'locator' could not be skipped");
      }
    }
    if (std::strcmp(field, "foundation") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'foundation' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'foundation' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'foundation' contents could not be skipped");
      }
    }
    if (std::strcmp(field, "priority") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'priority' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'priority' could not be skipped");
      }
    }
    if (std::strcmp(field, "type") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'type' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'type' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::IceCandidate_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "key") == 0) {
      return make_field_cmp(&T::key, next);
    }
    if (std::strncmp(field, "locator.", 8) == 0) {
      return make_struct_cmp(&T::locator, getMetaStruct<OpenDDS::DCPS::Locator_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strcmp(field, "foundation") == 0) {
      return make_field_cmp(&T::foundation, next);
    }
    if (std::strcmp(field, "priority") == 0) {
      return make_field_cmp(&T::priority, next);
    }
    if (std::strcmp(field, "type") == 0) {
      return make_field_cmp(&T::type, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceCandidate_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"key", "locator", "foundation", "priority", "type", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "key") == 0) {
      return &static_cast<const T*>(stru)->key;
    }
    if (std::strcmp(field, "locator") == 0) {
      return &static_cast<const T*>(stru)->locator;
    }
    if (std::strcmp(field, "foundation") == 0) {
      return &static_cast<const T*>(stru)->foundation;
    }
    if (std::strcmp(field, "priority") == 0) {
      return &static_cast<const T*>(stru)->priority;
    }
    if (std::strcmp(field, "type") == 0) {
      return &static_cast<const T*>(stru)->type;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceCandidate_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "key") == 0) {
      static_cast<T*>(lhs)->key = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "locator") == 0) {
      static_cast<T*>(lhs)->locator = *static_cast<const OpenDDS::DCPS::Locator_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "foundation") == 0) {
      static_cast<T*>(lhs)->foundation = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "priority") == 0) {
      static_cast<T*>(lhs)->priority = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "type") == 0) {
      static_cast<T*>(lhs)->type = *static_cast<const OpenDDS::RTPS::IceCandidateType_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceCandidate_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "key") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->key.in(), static_cast<const T*>(rhs)->key.in());
    }
    if (std::strcmp(field, "foundation") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->foundation.in(), static_cast<const T*>(rhs)->foundation.in());
    }
    if (std::strcmp(field, "priority") == 0) {
      return static_cast<const T*>(lhs)->priority == static_cast<const T*>(rhs)->priority;
    }
    if (std::strcmp(field, "type") == 0) {
      return static_cast<const T*>(lhs)->type == static_cast<const T*>(rhs)->type;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::IceCandidate_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::IceCandidate_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::IceCandidate_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::IceCandidate_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::IceCandidate_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: IceCandidate_t */


/* Begin TYPEDEF: BuiltinEndpointSet_t */


/* End TYPEDEF: BuiltinEndpointSet_t */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PUBLICATION_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_SUBSCRIPTION_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_PROXY_DETECTOR */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_ANNOUNCER */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_ANNOUNCER */


/* Begin CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_DETECTOR */


/* End CONST: DISC_BUILTIN_ENDPOINT_PARTICIPANT_STATE_DETECTOR */


/* Begin CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_WRITER */


/* End CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_WRITER */


/* Begin CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_READER */


/* End CONST: BUILTIN_ENDPOINT_PARTICIPANT_MESSAGE_DATA_READER */


/* Begin TYPEDEF: BuiltinEndpointQos_t */


/* End TYPEDEF: BuiltinEndpointQos_t */


/* Begin CONST: BEST_EFFORT_PARTICIPANT_MESSAGE_DATA_READER */


/* End CONST: BEST_EFFORT_PARTICIPANT_MESSAGE_DATA_READER */


/* Begin UNION-FWD: Parameter */


/* End UNION-FWD: Parameter */


/* Begin TYPEDEF: ParameterList */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParameterList& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i]._d() == OpenDDS::RTPS::PID_SENTINEL) continue;
    size_t param_size = 0, param_padding = 0;
    gen_find_size(seq[i], param_size, param_padding);
    size += param_size + param_padding;
    if (size % 4) {
      size += 4 - (size % 4);
    }
  }
  size += 4; /* PID_SENTINEL */
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    if (seq[i]._d() == OpenDDS::RTPS::PID_SENTINEL) continue;
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return (strm << OpenDDS::RTPS::PID_SENTINEL)
    && (strm << OpenDDS::RTPS::PID_PAD);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParameterList& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  while (true) {
    const CORBA::ULong len = seq.length();
    seq.length(len + 1);
    if (!(strm >> seq[len])) {
      return false;
    }
    if (seq[len]._d() == OpenDDS::RTPS::PID_SENTINEL) {
      seq.length(len);
      return true;
    }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParameterList*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: ParameterList */


/* Begin STRUCT: OriginalWriterInfo_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OriginalWriterInfo_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.originalWriterGUID, size, padding);
  gen_find_size(stru.originalWriterSN, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.originalWriterGUID)
    && (strm << stru.originalWriterSN);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OriginalWriterInfo_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.originalWriterGUID)
    && (strm >> stru.originalWriterSN);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t> : MetaStruct {
  typedef OpenDDS::RTPS::OriginalWriterInfo_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::OriginalWriterInfo_t& typed = *static_cast<const OpenDDS::RTPS::OriginalWriterInfo_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.originalWriterGUID, field + 19);
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.originalWriterSN, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 19);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'originalWriterGUID' could not be skipped");
      }
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 17);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'originalWriterSN' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::OriginalWriterInfo_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "originalWriterGUID.", 19) == 0) {
      return make_struct_cmp(&T::originalWriterGUID, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "originalWriterSN.", 17) == 0) {
      return make_struct_cmp(&T::originalWriterSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"originalWriterGUID", "originalWriterSN", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "originalWriterGUID") == 0) {
      return &static_cast<const T*>(stru)->originalWriterGUID;
    }
    if (std::strcmp(field, "originalWriterSN") == 0) {
      return &static_cast<const T*>(stru)->originalWriterSN;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "originalWriterGUID") == 0) {
      static_cast<T*>(lhs)->originalWriterGUID = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "originalWriterSN") == 0) {
      static_cast<T*>(lhs)->originalWriterSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OriginalWriterInfo_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::OriginalWriterInfo_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::OriginalWriterInfo_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::OriginalWriterInfo_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OriginalWriterInfo_t */


/* Begin TYPEDEF: ParameterId_t */


/* End TYPEDEF: ParameterId_t */


/* Begin CONST: PID_PAD */


/* End CONST: PID_PAD */


/* Begin CONST: PID_SENTINEL */


/* End CONST: PID_SENTINEL */


/* Begin CONST: PID_USER_DATA */


/* End CONST: PID_USER_DATA */


/* Begin CONST: PID_TOPIC_NAME */


/* End CONST: PID_TOPIC_NAME */


/* Begin CONST: PID_TYPE_NAME */


/* End CONST: PID_TYPE_NAME */


/* Begin CONST: PID_GROUP_DATA */


/* End CONST: PID_GROUP_DATA */


/* Begin CONST: PID_TOPIC_DATA */


/* End CONST: PID_TOPIC_DATA */


/* Begin CONST: PID_DURABILITY */


/* End CONST: PID_DURABILITY */


/* Begin CONST: PID_DURABILITY_SERVICE */


/* End CONST: PID_DURABILITY_SERVICE */


/* Begin CONST: PID_DEADLINE */


/* End CONST: PID_DEADLINE */


/* Begin CONST: PID_LATENCY_BUDGET */


/* End CONST: PID_LATENCY_BUDGET */


/* Begin CONST: PID_LIVELINESS */


/* End CONST: PID_LIVELINESS */


/* Begin CONST: PID_RELIABILITY */


/* End CONST: PID_RELIABILITY */


/* Begin CONST: PID_LIFESPAN */


/* End CONST: PID_LIFESPAN */


/* Begin CONST: PID_DESTINATION_ORDER */


/* End CONST: PID_DESTINATION_ORDER */


/* Begin CONST: PID_HISTORY */


/* End CONST: PID_HISTORY */


/* Begin CONST: PID_RESOURCE_LIMITS */


/* End CONST: PID_RESOURCE_LIMITS */


/* Begin CONST: PID_OWNERSHIP */


/* End CONST: PID_OWNERSHIP */


/* Begin CONST: PID_OWNERSHIP_STRENGTH */


/* End CONST: PID_OWNERSHIP_STRENGTH */


/* Begin CONST: PID_PRESENTATION */


/* End CONST: PID_PRESENTATION */


/* Begin CONST: PID_PARTITION */


/* End CONST: PID_PARTITION */


/* Begin CONST: PID_TIME_BASED_FILTER */


/* End CONST: PID_TIME_BASED_FILTER */


/* Begin CONST: PID_TRANSPORT_PRIORITY */


/* End CONST: PID_TRANSPORT_PRIORITY */


/* Begin CONST: PID_PROTOCOL_VERSION */


/* End CONST: PID_PROTOCOL_VERSION */


/* Begin CONST: PID_VENDORID */


/* End CONST: PID_VENDORID */


/* Begin CONST: PID_UNICAST_LOCATOR */


/* End CONST: PID_UNICAST_LOCATOR */


/* Begin CONST: PID_MULTICAST_LOCATOR */


/* End CONST: PID_MULTICAST_LOCATOR */


/* Begin CONST: PID_DEFAULT_UNICAST_LOCATOR */


/* End CONST: PID_DEFAULT_UNICAST_LOCATOR */


/* Begin CONST: PID_DEFAULT_MULTICAST_LOCATOR */


/* End CONST: PID_DEFAULT_MULTICAST_LOCATOR */


/* Begin CONST: PID_METATRAFFIC_UNICAST_LOCATOR */


/* End CONST: PID_METATRAFFIC_UNICAST_LOCATOR */


/* Begin CONST: PID_METATRAFFIC_MULTICAST_LOCATOR */


/* End CONST: PID_METATRAFFIC_MULTICAST_LOCATOR */


/* Begin CONST: PID_EXPECTS_INLINE_QOS */


/* End CONST: PID_EXPECTS_INLINE_QOS */


/* Begin CONST: PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT */


/* End CONST: PID_PARTICIPANT_MANUAL_LIVELINESS_COUNT */


/* Begin CONST: PID_PARTICIPANT_BUILTIN_ENDPOINTS */


/* End CONST: PID_PARTICIPANT_BUILTIN_ENDPOINTS */


/* Begin CONST: PID_PARTICIPANT_LEASE_DURATION */


/* End CONST: PID_PARTICIPANT_LEASE_DURATION */


/* Begin CONST: PID_CONTENT_FILTER_PROPERTY */


/* End CONST: PID_CONTENT_FILTER_PROPERTY */


/* Begin CONST: PID_PARTICIPANT_GUID */


/* End CONST: PID_PARTICIPANT_GUID */


/* Begin CONST: PID_GROUP_GUID */


/* End CONST: PID_GROUP_GUID */


/* Begin CONST: PID_BUILTIN_ENDPOINT_SET */


/* End CONST: PID_BUILTIN_ENDPOINT_SET */


/* Begin CONST: PID_PROPERTY_LIST */


/* End CONST: PID_PROPERTY_LIST */


/* Begin CONST: PID_TYPE_MAX_SIZE_SERIALIZED */


/* End CONST: PID_TYPE_MAX_SIZE_SERIALIZED */


/* Begin CONST: PID_ENTITY_NAME */


/* End CONST: PID_ENTITY_NAME */


/* Begin CONST: PID_KEY_HASH */


/* End CONST: PID_KEY_HASH */


/* Begin CONST: PID_STATUS_INFO */


/* End CONST: PID_STATUS_INFO */


/* Begin CONST: PID_ENDPOINT_GUID */


/* End CONST: PID_ENDPOINT_GUID */


/* Begin CONST: PID_CONTENT_FILTER_INFO */


/* End CONST: PID_CONTENT_FILTER_INFO */


/* Begin CONST: PID_COHERENT_SET */


/* End CONST: PID_COHERENT_SET */


/* Begin CONST: PID_DIRECTED_WRITE */


/* End CONST: PID_DIRECTED_WRITE */


/* Begin CONST: PID_ORIGINAL_WRITER_INFO */


/* End CONST: PID_ORIGINAL_WRITER_INFO */


/* Begin CONST: PIDMASK_VENDOR_SPECIFIC */


/* End CONST: PIDMASK_VENDOR_SPECIFIC */


/* Begin CONST: PIDMASK_INCOMPATIBLE */


/* End CONST: PIDMASK_INCOMPATIBLE */


/* Begin CONST: PID_DOMAIN_ID */


/* End CONST: PID_DOMAIN_ID */


/* Begin CONST: PID_DOMAIN_TAG */


/* End CONST: PID_DOMAIN_TAG */


/* Begin CONST: PID_BUILTIN_ENDPOINT_QOS */


/* End CONST: PID_BUILTIN_ENDPOINT_QOS */


/* Begin TYPEDEF: OpenDDSParticipantFlagsBits_t */


/* End TYPEDEF: OpenDDSParticipantFlagsBits_t */


/* Begin CONST: PFLAGS_EMPTY */


/* End CONST: PFLAGS_EMPTY */


/* Begin CONST: PFLAGS_NO_ASSOCIATED_WRITERS */


/* End CONST: PFLAGS_NO_ASSOCIATED_WRITERS */


/* Begin STRUCT: OpenDDSParticipantFlags_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::OpenDDSParticipantFlags_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.bits);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::OpenDDSParticipantFlags_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.bits);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::OpenDDSParticipantFlags_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.bits);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::OpenDDSParticipantFlags_t> : MetaStruct {
  typedef OpenDDS::RTPS::OpenDDSParticipantFlags_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::OpenDDSParticipantFlags_t& typed = *static_cast<const OpenDDS::RTPS::OpenDDSParticipantFlags_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "bits") == 0) {
      return typed.bits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "bits") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'bits' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'bits' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::OpenDDSParticipantFlags_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "bits") == 0) {
      return make_field_cmp(&T::bits, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"bits", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bits") == 0) {
      return &static_cast<const T*>(stru)->bits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bits") == 0) {
      static_cast<T*>(lhs)->bits = *static_cast<const OpenDDS::RTPS::OpenDDSParticipantFlagsBits_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "bits") == 0) {
      return static_cast<const T*>(lhs)->bits == static_cast<const T*>(rhs)->bits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::OpenDDSParticipantFlags_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::OpenDDSParticipantFlags_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::OpenDDSParticipantFlags_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::OpenDDSParticipantFlags_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::OpenDDSParticipantFlags_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: OpenDDSParticipantFlags_t */


/* Begin CONST: PID_OPENDDS_BASE */


/* End CONST: PID_OPENDDS_BASE */


/* Begin CONST: PID_OPENDDS_LOCATOR */


/* End CONST: PID_OPENDDS_LOCATOR */


/* Begin CONST: PID_OPENDDS_ASSOCIATED_WRITER */


/* End CONST: PID_OPENDDS_ASSOCIATED_WRITER */


/* Begin CONST: PID_OPENDDS_ICE_GENERAL */


/* End CONST: PID_OPENDDS_ICE_GENERAL */


/* Begin CONST: PID_OPENDDS_ICE_CANDIDATE */


/* End CONST: PID_OPENDDS_ICE_CANDIDATE */


/* Begin CONST: PID_OPENDDS_PARTICIPANT_FLAGS */


/* End CONST: PID_OPENDDS_PARTICIPANT_FLAGS */


/* Begin UNION: Parameter */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Parameter& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  switch (uni._d()) {
  case 5u:
  case 7u: {
    find_size_ulong(size, padding);
    size += ACE_OS::strlen(uni.string_data()) + 1;
    break;
  }
  case 44u: {
    gen_find_size(uni.user_data(), size, padding);
    break;
  }
  case 45u: {
    gen_find_size(uni.group_data(), size, padding);
    break;
  }
  case 46u: {
    gen_find_size(uni.topic_data(), size, padding);
    break;
  }
  case 29u: {
    gen_find_size(uni.durability(), size, padding);
    break;
  }
  case 30u: {
    gen_find_size(uni.durability_service(), size, padding);
    break;
  }
  case 35u: {
    gen_find_size(uni.deadline(), size, padding);
    break;
  }
  case 39u: {
    gen_find_size(uni.latency_budget(), size, padding);
    break;
  }
  case 27u: {
    gen_find_size(uni.liveliness(), size, padding);
    break;
  }
  case 26u: {
    gen_find_size(uni.reliability(), size, padding);
    break;
  }
  case 43u: {
    gen_find_size(uni.lifespan(), size, padding);
    break;
  }
  case 37u: {
    gen_find_size(uni.destination_order(), size, padding);
    break;
  }
  case 64u: {
    gen_find_size(uni.history(), size, padding);
    break;
  }
  case 65u: {
    gen_find_size(uni.resource_limits(), size, padding);
    break;
  }
  case 31u: {
    gen_find_size(uni.ownership(), size, padding);
    break;
  }
  case 6u: {
    gen_find_size(uni.ownership_strength(), size, padding);
    break;
  }
  case 33u: {
    gen_find_size(uni.presentation(), size, padding);
    break;
  }
  case 41u: {
    gen_find_size(uni.partition(), size, padding);
    break;
  }
  case 4u: {
    gen_find_size(uni.time_based_filter(), size, padding);
    break;
  }
  case 73u: {
    gen_find_size(uni.transport_priority(), size, padding);
    break;
  }
  case 21u: {
    gen_find_size(uni.version(), size, padding);
    break;
  }
  case 22u: {
    gen_find_size(uni.vendor(), size, padding);
    break;
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    gen_find_size(uni.locator(), size, padding);
    break;
  }
  case 67u: {
    size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(uni.expects_inline_qos()));
    break;
  }
  case 52u: {
    gen_find_size(uni.count(), size, padding);
    break;
  }
  case 68u: {
    if ((size + padding) % 4) {
      padding += 4 - ((size + padding) % 4);
    }
    size += gen_max_marshaled_size(uni.participant_builtin_endpoints());
    break;
  }
  case 2u: {
    gen_find_size(uni.duration(), size, padding);
    break;
  }
  case 53u: {
    gen_find_size(uni.content_filter_property(), size, padding);
    break;
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    gen_find_size(uni.guid(), size, padding);
    break;
  }
  case 45061u: {
    gen_find_size(uni.participant_flags(), size, padding);
    break;
  }
  case 88u: {
    if ((size + padding) % 4) {
      padding += 4 - ((size + padding) % 4);
    }
    size += gen_max_marshaled_size(uni.builtin_endpoints());
    break;
  }
  case 89u: {
    gen_find_size(uni.property(), size, padding);
    break;
  }
  case 96u: {
    if ((size + padding) % 4) {
      padding += 4 - ((size + padding) % 4);
    }
    size += gen_max_marshaled_size(uni.type_max_size_serialized());
    break;
  }
  case 98u: {
    gen_find_size(uni.entity_name(), size, padding);
    break;
  }
  case 112u: {
    gen_find_size(uni.key_hash(), size, padding);
    break;
  }
  case 113u: {
    gen_find_size(uni.status_info(), size, padding);
    break;
  }
  case 85u: {
    gen_find_size(uni.content_filter_info(), size, padding);
    break;
  }
  case 86u: {
    gen_find_size(uni.coherent_set(), size, padding);
    break;
  }
  case 97u: {
    gen_find_size(uni.original_writer_info(), size, padding);
    break;
  }
  case 45057u: {
    gen_find_size(uni.opendds_locator(), size, padding);
    break;
  }
  case 45059u: {
    gen_find_size(uni.ice_general(), size, padding);
    break;
  }
  case 45060u: {
    gen_find_size(uni.ice_candidate(), size, padding);
    break;
  }
  case 15u: {
    if ((size + padding) % 4) {
      padding += 4 - ((size + padding) % 4);
    }
    size += gen_max_marshaled_size(uni.domainId());
    break;
  }
  case 16404u: {
    find_size_ulong(size, padding);
    size += ACE_OS::strlen(uni.domainTag()) + 1;
    break;
  }
  case 119u: {
    if ((size + padding) % 4) {
      padding += 4 - ((size + padding) % 4);
    }
    size += gen_max_marshaled_size(uni.builtinEndpointQos());
    break;
  }
  default: {
    gen_find_size(uni.unknown_data(), size, padding);
    break;
  }
  }
  size += 4; // parameterId & length
}

bool operator<<(Serializer& outer_strm, const OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(outer_strm);
  ACE_UNUSED_ARG(uni);
  if (!(outer_strm << uni._d())) {
    return false;
  }
  size_t size = 0, pad = 0;
  gen_find_size(uni, size, pad);
  size -= 4; // parameterId & length
  const size_t post_pad = 4 - ((size + pad) % 4);
  const size_t total = size + pad + ((post_pad < 4) ? post_pad : 0);
  if (size + pad > ACE_UINT16_MAX || !(outer_strm << ACE_CDR::UShort(total))) {
    return false;
  }
  ACE_Message_Block param(size + pad);
  Serializer strm(&param, outer_strm.swap_bytes(), outer_strm.alignment());
  if (!insertParamData(strm, uni)) {
    return false;
  }
  const ACE_CDR::Octet* data = reinterpret_cast<ACE_CDR::Octet*>(param.rd_ptr());
  if (!outer_strm.write_octet_array(data, ACE_CDR::ULong(param.length()))) {
    return false;
  }
  if (post_pad < 4 && outer_strm.alignment() != Serializer::ALIGN_NONE) {
    static const ACE_CDR::Octet padding[3] = {0};
    return outer_strm.write_octet_array(padding, ACE_CDR::ULong(post_pad));
  }
  return true;
}

bool insertParamData(Serializer& strm, const OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case 5u:
  case 7u: {
    return (strm << ACE_OutputCDR::from_string(uni.string_data(), 256));
  }
  case 44u: {
    return (strm << uni.user_data());
  }
  case 45u: {
    return (strm << uni.group_data());
  }
  case 46u: {
    return (strm << uni.topic_data());
  }
  case 29u: {
    return (strm << uni.durability());
  }
  case 30u: {
    return (strm << uni.durability_service());
  }
  case 35u: {
    return (strm << uni.deadline());
  }
  case 39u: {
    return (strm << uni.latency_budget());
  }
  case 27u: {
    return (strm << uni.liveliness());
  }
  case 26u: {
    return (strm << uni.reliability());
  }
  case 43u: {
    return (strm << uni.lifespan());
  }
  case 37u: {
    return (strm << uni.destination_order());
  }
  case 64u: {
    return (strm << uni.history());
  }
  case 65u: {
    return (strm << uni.resource_limits());
  }
  case 31u: {
    return (strm << uni.ownership());
  }
  case 6u: {
    return (strm << uni.ownership_strength());
  }
  case 33u: {
    return (strm << uni.presentation());
  }
  case 41u: {
    return (strm << uni.partition());
  }
  case 4u: {
    return (strm << uni.time_based_filter());
  }
  case 73u: {
    return (strm << uni.transport_priority());
  }
  case 21u: {
    return (strm << uni.version());
  }
  case 22u: {
    return (strm << uni.vendor());
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    return (strm << uni.locator());
  }
  case 67u: {
    return (strm << ACE_OutputCDR::from_boolean(uni.expects_inline_qos()));
  }
  case 52u: {
    return (strm << uni.count());
  }
  case 68u: {
    return (strm << uni.participant_builtin_endpoints());
  }
  case 2u: {
    return (strm << uni.duration());
  }
  case 53u: {
    return (strm << uni.content_filter_property());
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    return (strm << uni.guid());
  }
  case 45061u: {
    return (strm << uni.participant_flags());
  }
  case 88u: {
    return (strm << uni.builtin_endpoints());
  }
  case 89u: {
    return (strm << uni.property());
  }
  case 96u: {
    return (strm << uni.type_max_size_serialized());
  }
  case 98u: {
    return (strm << uni.entity_name());
  }
  case 112u: {
    return (strm << uni.key_hash());
  }
  case 113u: {
    return (strm << uni.status_info());
  }
  case 85u: {
    return (strm << uni.content_filter_info());
  }
  case 86u: {
    return (strm << uni.coherent_set());
  }
  case 97u: {
    return (strm << uni.original_writer_info());
  }
  case 45057u: {
    return (strm << uni.opendds_locator());
  }
  case 45059u: {
    return (strm << uni.ice_general());
  }
  case 45060u: {
    return (strm << uni.ice_candidate());
  }
  case 15u: {
    return (strm << uni.domainId());
  }
  case 16404u: {
    return (strm << ACE_OutputCDR::from_string(uni.domainTag(), 256));
  }
  case 119u: {
    return (strm << uni.builtinEndpointQos());
  }
  default: {
    return (strm << uni.unknown_data());
  }
  }
}

bool operator>>(Serializer& outer_strm, OpenDDS::RTPS::Parameter& uni)
{
  ACE_UNUSED_ARG(outer_strm);
  ACE_UNUSED_ARG(uni);
  ACE_CDR::UShort disc, size;
  if (!(outer_strm >> disc) || !(outer_strm >> size)) {
    return false;
  }
  if (disc == OpenDDS::RTPS::PID_SENTINEL) {
    uni._d(OpenDDS::RTPS::PID_SENTINEL);
    return true;
  }
  ACE_Message_Block param(size);
  ACE_CDR::Octet* data = reinterpret_cast<ACE_CDR::Octet*>(param.wr_ptr());
  if (!outer_strm.read_octet_array(data, size)) {
    return false;
  }
  param.wr_ptr(size);
  Serializer strm(&param, outer_strm.swap_bytes(), Serializer::ALIGN_CDR);
  switch (disc) {
  case 5u:
  case 7u: {
    CORBA::String_var tmp;
    if (strm >> tmp.out()) {
      uni.string_data(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 44u: {
    DDS::UserDataQosPolicy tmp;
    if (strm >> tmp) {
      uni.user_data(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 45u: {
    DDS::GroupDataQosPolicy tmp;
    if (strm >> tmp) {
      uni.group_data(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 46u: {
    DDS::TopicDataQosPolicy tmp;
    if (strm >> tmp) {
      uni.topic_data(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 29u: {
    DDS::DurabilityQosPolicy tmp;
    if (strm >> tmp) {
      uni.durability(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 30u: {
    DDS::DurabilityServiceQosPolicy tmp;
    if (strm >> tmp) {
      uni.durability_service(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 35u: {
    DDS::DeadlineQosPolicy tmp;
    if (strm >> tmp) {
      uni.deadline(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 39u: {
    DDS::LatencyBudgetQosPolicy tmp;
    if (strm >> tmp) {
      uni.latency_budget(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 27u: {
    DDS::LivelinessQosPolicy tmp;
    if (strm >> tmp) {
      uni.liveliness(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 26u: {
    DDS::ReliabilityQosPolicy tmp;
    if (strm >> tmp) {
      uni.reliability(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 43u: {
    DDS::LifespanQosPolicy tmp;
    if (strm >> tmp) {
      uni.lifespan(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 37u: {
    DDS::DestinationOrderQosPolicy tmp;
    if (strm >> tmp) {
      uni.destination_order(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 64u: {
    DDS::HistoryQosPolicy tmp;
    if (strm >> tmp) {
      uni.history(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 65u: {
    DDS::ResourceLimitsQosPolicy tmp;
    if (strm >> tmp) {
      uni.resource_limits(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 31u: {
    DDS::OwnershipQosPolicy tmp;
    if (strm >> tmp) {
      uni.ownership(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 6u: {
    DDS::OwnershipStrengthQosPolicy tmp;
    if (strm >> tmp) {
      uni.ownership_strength(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 33u: {
    DDS::PresentationQosPolicy tmp;
    if (strm >> tmp) {
      uni.presentation(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 41u: {
    DDS::PartitionQosPolicy tmp;
    if (strm >> tmp) {
      uni.partition(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 4u: {
    DDS::TimeBasedFilterQosPolicy tmp;
    if (strm >> tmp) {
      uni.time_based_filter(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 73u: {
    DDS::TransportPriorityQosPolicy tmp;
    if (strm >> tmp) {
      uni.transport_priority(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 21u: {
    OpenDDS::RTPS::ProtocolVersion_t tmp;
    if (strm >> tmp) {
      uni.version(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 22u: {
    OpenDDS::RTPS::VendorId_t tmp;
    if (strm >> tmp) {
      uni.vendor(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    OpenDDS::DCPS::Locator_t tmp;
    if (strm >> tmp) {
      uni.locator(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 67u: {
    CORBA::Boolean tmp;
    if (strm >> ACE_InputCDR::to_boolean(tmp)) {
      uni.expects_inline_qos(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 52u: {
    OpenDDS::RTPS::Count_t tmp;
    if (strm >> tmp) {
      uni.count(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 68u: {
    CORBA::ULong tmp;
    if (strm >> tmp) {
      uni.participant_builtin_endpoints(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 2u: {
    OpenDDS::RTPS::Duration_t tmp;
    if (strm >> tmp) {
      uni.duration(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 53u: {
    OpenDDS::DCPS::ContentFilterProperty_t tmp;
    if (strm >> tmp) {
      uni.content_filter_property(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    OpenDDS::DCPS::GUID_t tmp;
    if (strm >> tmp) {
      uni.guid(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 45061u: {
    OpenDDS::RTPS::OpenDDSParticipantFlags_t tmp;
    if (strm >> tmp) {
      uni.participant_flags(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 88u: {
    OpenDDS::RTPS::BuiltinEndpointSet_t tmp;
    if (strm >> tmp) {
      uni.builtin_endpoints(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 89u: {
    DDS::PropertyQosPolicy tmp;
    if (strm >> tmp) {
      uni.property(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 96u: {
    CORBA::Long tmp;
    if (strm >> tmp) {
      uni.type_max_size_serialized(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 98u: {
    OpenDDS::RTPS::EntityName_t tmp;
    if (strm >> tmp) {
      uni.entity_name(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 112u: {
    OpenDDS::RTPS::KeyHash_t tmp;
    if (strm >> tmp) {
      uni.key_hash(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 113u: {
    OpenDDS::RTPS::StatusInfo_t tmp;
    if (strm >> tmp) {
      uni.status_info(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 85u: {
    OpenDDS::RTPS::ContentFilterInfo_t tmp;
    if (strm >> tmp) {
      uni.content_filter_info(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 86u: {
    OpenDDS::RTPS::SequenceNumber_t tmp;
    if (strm >> tmp) {
      uni.coherent_set(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 97u: {
    OpenDDS::RTPS::OriginalWriterInfo_t tmp;
    if (strm >> tmp) {
      uni.original_writer_info(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 45057u: {
    OpenDDS::DCPS::TransportLocator tmp;
    if (strm >> tmp) {
      uni.opendds_locator(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 45059u: {
    OpenDDS::RTPS::IceGeneral_t tmp;
    if (strm >> tmp) {
      uni.ice_general(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 45060u: {
    OpenDDS::RTPS::IceCandidate_t tmp;
    if (strm >> tmp) {
      uni.ice_candidate(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 15u: {
    DDS::DomainId_t tmp;
    if (strm >> tmp) {
      uni.domainId(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 16404u: {
    CORBA::String_var tmp;
    if (strm >> tmp.out()) {
      uni.domainTag(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  case 119u: {
    OpenDDS::RTPS::BuiltinEndpointQos_t tmp;
    if (strm >> tmp) {
      uni.builtinEndpointQos(tmp);
      uni._d(disc);
      return true;
    }
    return false;
  }
  default:
    {
      uni.unknown_data(DDS::OctetSeq(size));
      uni.unknown_data().length(size);
      std::memcpy(uni.unknown_data().get_buffer(), data, size);
      uni._d(disc);
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Parameter> : MetaStruct {
  typedef OpenDDS::RTPS::Parameter T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Parameter& typed = *static_cast<const OpenDDS::RTPS::Parameter*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Parameter)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    ACE_UNUSED_ARG(ser);
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Parameter");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Parameter)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    ACE_UNUSED_ARG(stru);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Parameter)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Parameter)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Parameter)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Parameter>()
{
  static MetaStructImpl<OpenDDS::RTPS::Parameter> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::Parameter*)
{
  ACE_UNUSED_ARG(ser);
  CORBA::UShort disc;
  if (!(ser >> disc)) {
    return false;
  }
  switch (disc) {
  case 5u:
  case 7u: {
    ACE_CDR::ULong len;
    if (!(ser >> len)) return false;
    if (!ser.skip(static_cast<ACE_UINT16>(len))) return false;
    return true;
  }
  case 44u: {
    if (!gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0))) return false;
    return true;
  }
  case 45u: {
    if (!gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0))) return false;
    return true;
  }
  case 46u: {
    if (!gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0))) return false;
    return true;
  }
  case 29u: {
    if (!gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0))) return false;
    return true;
  }
  case 30u: {
    if (!gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0))) return false;
    return true;
  }
  case 35u: {
    if (!gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0))) return false;
    return true;
  }
  case 39u: {
    if (!gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0))) return false;
    return true;
  }
  case 27u: {
    if (!gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0))) return false;
    return true;
  }
  case 26u: {
    if (!gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0))) return false;
    return true;
  }
  case 43u: {
    if (!gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0))) return false;
    return true;
  }
  case 37u: {
    if (!gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0))) return false;
    return true;
  }
  case 64u: {
    if (!gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0))) return false;
    return true;
  }
  case 65u: {
    if (!gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0))) return false;
    return true;
  }
  case 31u: {
    if (!gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0))) return false;
    return true;
  }
  case 6u: {
    if (!gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0))) return false;
    return true;
  }
  case 33u: {
    if (!gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0))) return false;
    return true;
  }
  case 41u: {
    if (!gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0))) return false;
    return true;
  }
  case 4u: {
    if (!gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0))) return false;
    return true;
  }
  case 73u: {
    if (!gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0))) return false;
    return true;
  }
  case 21u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0))) return false;
    return true;
  }
  case 22u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0))) return false;
    return true;
  }
  case 47u:
  case 48u:
  case 49u:
  case 72u:
  case 50u:
  case 51u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::Locator_t*>(0))) return false;
    return true;
  }
  case 67u: {
    if (!ser.skip(1, 1)) return false;
    return true;
  }
  case 52u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0))) return false;
    return true;
  }
  case 68u: {
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 2u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Duration_t*>(0))) return false;
    return true;
  }
  case 53u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::ContentFilterProperty_t*>(0))) return false;
    return true;
  }
  case 80u:
  case 90u:
  case 82u:
  case 45058u:
  case 87u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0))) return false;
    return true;
  }
  case 45061u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::OpenDDSParticipantFlags_t*>(0))) return false;
    return true;
  }
  case 88u: {
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 89u: {
    if (!gen_skip_over(ser, static_cast<DDS::PropertyQosPolicy*>(0))) return false;
    return true;
  }
  case 96u: {
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 98u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::EntityName_t*>(0))) return false;
    return true;
  }
  case 112u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::KeyHash_t*>(0))) return false;
    return true;
  }
  case 113u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::StatusInfo_t*>(0))) return false;
    return true;
  }
  case 85u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::ContentFilterInfo_t*>(0))) return false;
    return true;
  }
  case 86u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) return false;
    return true;
  }
  case 97u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::OriginalWriterInfo_t*>(0))) return false;
    return true;
  }
  case 45057u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocator*>(0))) return false;
    return true;
  }
  case 45059u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::IceGeneral_t*>(0))) return false;
    return true;
  }
  case 45060u: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::IceCandidate_t*>(0))) return false;
    return true;
  }
  case 15u: {
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  case 16404u: {
    ACE_CDR::ULong len;
    if (!(ser >> len)) return false;
    if (!ser.skip(static_cast<ACE_UINT16>(len))) return false;
    return true;
  }
  case 119u: {
    if (!ser.skip(1, 4)) return false;
    return true;
  }
  default: {
    if (!gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0))) return false;
    return true;
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: Parameter */


/* Begin CONST: FLAG_E */


/* End CONST: FLAG_E */


/* Begin CONST: FLAG_Q */


/* End CONST: FLAG_Q */


/* Begin CONST: FLAG_F */


/* End CONST: FLAG_F */


/* Begin CONST: FLAG_I */


/* End CONST: FLAG_I */


/* Begin CONST: FLAG_M */


/* End CONST: FLAG_M */


/* Begin CONST: FLAG_D */


/* End CONST: FLAG_D */


/* Begin CONST: FLAG_L */


/* End CONST: FLAG_L */


/* Begin CONST: FLAG_K_IN_FRAG */


/* End CONST: FLAG_K_IN_FRAG */


/* Begin CONST: FLAG_K_IN_DATA */


/* End CONST: FLAG_K_IN_DATA */


/* Begin CONST: FLAG_N_IN_FRAG */


/* End CONST: FLAG_N_IN_FRAG */


/* Begin CONST: FLAG_N_IN_DATA */


/* End CONST: FLAG_N_IN_DATA */


/* Begin STRUCT: SubmessageHeader */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SubmessageHeader& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.submessageId));
  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.flags));
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.submessageLength);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  strm.swap_bytes(ACE_CDR_BYTE_ORDER != (stru.flags & 1));
  return (strm << ACE_OutputCDR::from_octet(stru.submessageId))
    && (strm << ACE_OutputCDR::from_octet(stru.flags))
    && (strm << stru.submessageLength);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageHeader& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> ACE_InputCDR::to_octet(stru.submessageId))
    && (strm >> ACE_InputCDR::to_octet(stru.flags))
    && (strm >> stru.submessageLength);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SubmessageHeader> : MetaStruct {
  typedef OpenDDS::RTPS::SubmessageHeader T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SubmessageHeader& typed = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "submessageId") == 0) {
      return typed.submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return typed.flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return typed.submessageLength;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "submessageId") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'submessageId' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'submessageId' could not be skipped");
      }
    }
    if (std::strcmp(field, "flags") == 0) {
      ACE_CDR::Octet val;
      if (!(ser >> ACE_InputCDR::to_octet(val))) {
        throw std::runtime_error("Field 'flags' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'flags' could not be skipped");
      }
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'submessageLength' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'submessageLength' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SubmessageHeader");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "submessageId") == 0) {
      return make_field_cmp(&T::submessageId, next);
    }
    if (std::strcmp(field, "flags") == 0) {
      return make_field_cmp(&T::flags, next);
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return make_field_cmp(&T::submessageLength, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"submessageId", "flags", "submessageLength", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "submessageId") == 0) {
      return &static_cast<const T*>(stru)->submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return &static_cast<const T*>(stru)->flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return &static_cast<const T*>(stru)->submessageLength;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "submessageId") == 0) {
      static_cast<T*>(lhs)->submessageId = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "flags") == 0) {
      static_cast<T*>(lhs)->flags = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      static_cast<T*>(lhs)->submessageLength = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "submessageId") == 0) {
      return static_cast<const T*>(lhs)->submessageId == static_cast<const T*>(rhs)->submessageId;
    }
    if (std::strcmp(field, "flags") == 0) {
      return static_cast<const T*>(lhs)->flags == static_cast<const T*>(rhs)->flags;
    }
    if (std::strcmp(field, "submessageLength") == 0) {
      return static_cast<const T*>(lhs)->submessageLength == static_cast<const T*>(rhs)->submessageLength;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SubmessageHeader)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SubmessageHeader>()
{
  static MetaStructImpl<OpenDDS::RTPS::SubmessageHeader> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::SubmessageHeader*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SubmessageHeader */


/* Begin STRUCT: FragmentNumber_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FragmentNumber_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.value);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.value);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FragmentNumber_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.value);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t> : MetaStruct {
  typedef OpenDDS::RTPS::FragmentNumber_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::FragmentNumber_t& typed = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "value") == 0) {
      return typed.value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'value' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'value' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::FragmentNumber_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "value") == 0) {
      return make_field_cmp(&T::value, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"value", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "value") == 0) {
      return &static_cast<const T*>(stru)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "value") == 0) {
      static_cast<T*>(lhs)->value = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "value") == 0) {
      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumber_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::FragmentNumber_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: FragmentNumber_t */


/* Begin STRUCT: FragmentNumberSet */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::FragmentNumberSet& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  size += 8 + 4 * ((stru.numBits + 31) / 32); // RTPS Custom
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm << stru.bitmapBase) && (strm << stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (stru.bitmap.length() < M) {
      return false;
    }
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm << stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::FragmentNumberSet& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if ((strm >> stru.bitmapBase) && (strm >> stru.numBits)) {
    const CORBA::ULong M = (stru.numBits + 31) / 32;
    if (M > 8) {
      return false;
    }
    stru.bitmap.length(M);
    for (CORBA::ULong i = 0; i < M; ++i) {
      if (!(strm >> stru.bitmap[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet> : MetaStruct {
  typedef OpenDDS::RTPS::FragmentNumberSet T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::FragmentNumberSet& typed = *static_cast<const OpenDDS::RTPS::FragmentNumberSet*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.bitmapBase, field + 11);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return typed.numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 11);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0))) {
        throw std::runtime_error("Field 'bitmapBase' could not be skipped");
      }
    }
    if (std::strcmp(field, "numBits") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'numBits' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'numBits' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::LongSeq8*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::FragmentNumberSet");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "bitmapBase.", 11) == 0) {
      return make_struct_cmp(&T::bitmapBase, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 11), next);
    }
    if (std::strcmp(field, "numBits") == 0) {
      return make_field_cmp(&T::numBits, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"bitmapBase", "numBits", "bitmap", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "bitmapBase") == 0) {
      return &static_cast<const T*>(stru)->bitmapBase;
    }
    if (std::strcmp(field, "numBits") == 0) {
      return &static_cast<const T*>(stru)->numBits;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      return &static_cast<const T*>(stru)->bitmap;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "bitmapBase") == 0) {
      static_cast<T*>(lhs)->bitmapBase = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "numBits") == 0) {
      static_cast<T*>(lhs)->numBits = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "bitmap") == 0) {
      static_cast<T*>(lhs)->bitmap = *static_cast<const OpenDDS::RTPS::LongSeq8*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "numBits") == 0) {
      return static_cast<const T*>(lhs)->numBits == static_cast<const T*>(rhs)->numBits;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::FragmentNumberSet)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>()
{
  static MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::FragmentNumberSet*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::FragmentNumberSet>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: FragmentNumberSet */


/* Begin STRUCT: AckNackSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::AckNackSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.readerSNState, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.readerSNState)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::AckNackSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.readerSNState)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::AckNackSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::AckNackSubmessage& typed = *static_cast<const OpenDDS::RTPS::AckNackSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(&typed.readerSNState, field + 14);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, field + 14);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumberSet*>(0))) {
        throw std::runtime_error("Field 'readerSNState' could not be skipped");
      }
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::AckNackSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerSNState.", 14) == 0) {
      return make_struct_cmp(&T::readerSNState, getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().create_qc_comparator(field + 14), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "readerSNState", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "readerSNState") == 0) {
      return &static_cast<const T*>(stru)->readerSNState;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerSNState") == 0) {
      static_cast<T*>(lhs)->readerSNState = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::AckNackSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::AckNackSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::AckNackSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::AckNackSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: AckNackSubmessage */


/* Begin STRUCT: GapSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::GapSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.gapStart, size, padding);
  gen_find_size(stru.gapList, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.gapStart)
    && (strm << stru.gapList);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::GapSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.gapStart)
    && (strm >> stru.gapList);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::GapSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::GapSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::GapSubmessage& typed = *static_cast<const OpenDDS::RTPS::GapSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.gapStart, field + 9);
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(&typed.gapList, field + 8);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'gapStart' could not be skipped");
      }
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().getValue(ser, field + 8);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumberSet*>(0))) {
        throw std::runtime_error("Field 'gapList' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::GapSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "gapStart.", 9) == 0) {
      return make_struct_cmp(&T::gapStart, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "gapList.", 8) == 0) {
      return make_struct_cmp(&T::gapList, getMetaStruct<OpenDDS::RTPS::SequenceNumberSet>().create_qc_comparator(field + 8), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "gapStart", "gapList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "gapStart") == 0) {
      return &static_cast<const T*>(stru)->gapStart;
    }
    if (std::strcmp(field, "gapList") == 0) {
      return &static_cast<const T*>(stru)->gapList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "gapStart") == 0) {
      static_cast<T*>(lhs)->gapStart = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "gapList") == 0) {
      static_cast<T*>(lhs)->gapList = *static_cast<const OpenDDS::RTPS::SequenceNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::GapSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::GapSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::GapSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::GapSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::GapSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: GapSubmessage */


/* Begin STRUCT: InfoReplySubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoReplySubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.unicastLocatorList, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.multicastLocatorList, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.unicastLocatorList)
    && (!(stru.smHeader.flags & 2) || (strm << stru.multicastLocatorList));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoReplySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.unicastLocatorList)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.multicastLocatorList));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoReplySubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoReplySubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoReplySubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorList*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorList*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoReplySubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unicastLocatorList", "multicastLocatorList", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->unicastLocatorList;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->multicastLocatorList;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocatorList") == 0) {
      static_cast<T*>(lhs)->unicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocatorList") == 0) {
      static_cast<T*>(lhs)->multicastLocatorList = *static_cast<const OpenDDS::RTPS::LocatorList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplySubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoReplySubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoReplySubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoReplySubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoReplySubmessage */


/* Begin STRUCT: NackFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::NackFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.fragmentNumberState, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.fragmentNumberState)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::NackFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.fragmentNumberState)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::NackFragSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::NackFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::NackFragSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().getValue(&typed.fragmentNumberState, field + 20);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'writerSN' could not be skipped");
      }
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().getValue(ser, field + 20);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumberSet*>(0))) {
        throw std::runtime_error("Field 'fragmentNumberState' could not be skipped");
      }
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::NackFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "fragmentNumberState.", 20) == 0) {
      return make_struct_cmp(&T::fragmentNumberState, getMetaStruct<OpenDDS::RTPS::FragmentNumberSet>().create_qc_comparator(field + 20), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "writerSN", "fragmentNumberState", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "fragmentNumberState") == 0) {
      return &static_cast<const T*>(stru)->fragmentNumberState;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentNumberState") == 0) {
      static_cast<T*>(lhs)->fragmentNumberState = *static_cast<const OpenDDS::RTPS::FragmentNumberSet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::NackFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::NackFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::NackFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::NackFragSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: NackFragSubmessage */


/* Begin STRUCT: ParticipantProxy_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParticipantProxy_t& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.domainId);
  find_size_ulong(size, padding);
  size += ACE_OS::strlen(stru.domainTag.in()) + 1;
  gen_find_size(stru.protocolVersion, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.expectsInlineQos));
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.availableBuiltinEndpoints);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.builtinEndpointQos);
  gen_find_size(stru.metatrafficUnicastLocatorList, size, padding);
  gen_find_size(stru.metatrafficMulticastLocatorList, size, padding);
  gen_find_size(stru.defaultMulticastLocatorList, size, padding);
  gen_find_size(stru.defaultUnicastLocatorList, size, padding);
  gen_find_size(stru.manualLivelinessCount, size, padding);
  gen_find_size(stru.property, size, padding);
  gen_find_size(stru.opendds_participant_flags, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.domainId)
    && (strm << ACE_OutputCDR::from_string(stru.domainTag.in(), 256))
    && (strm << stru.protocolVersion)
    && (strm << stru_guidPrefix)
    && (strm << stru.vendorId)
    && (strm << ACE_OutputCDR::from_boolean(stru.expectsInlineQos))
    && (strm << stru.availableBuiltinEndpoints)
    && (strm << stru.builtinEndpointQos)
    && (strm << stru.metatrafficUnicastLocatorList)
    && (strm << stru.metatrafficMulticastLocatorList)
    && (strm << stru.defaultMulticastLocatorList)
    && (strm << stru.defaultUnicastLocatorList)
    && (strm << stru.manualLivelinessCount)
    && (strm << stru.property)
    && (strm << stru.opendds_participant_flags);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParticipantProxy_t& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.domainId)
    && (strm >> ACE_InputCDR::to_string(stru.domainTag.out(), 256))
    && (strm >> stru.protocolVersion)
    && (strm >> stru_guidPrefix)
    && (strm >> stru.vendorId)
    && (strm >> ACE_InputCDR::to_boolean(stru.expectsInlineQos))
    && (strm >> stru.availableBuiltinEndpoints)
    && (strm >> stru.builtinEndpointQos)
    && (strm >> stru.metatrafficUnicastLocatorList)
    && (strm >> stru.metatrafficMulticastLocatorList)
    && (strm >> stru.defaultMulticastLocatorList)
    && (strm >> stru.defaultUnicastLocatorList)
    && (strm >> stru.manualLivelinessCount)
    && (strm >> stru.property)
    && (strm >> stru.opendds_participant_flags);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t> : MetaStruct {
  typedef OpenDDS::RTPS::ParticipantProxy_t T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ParticipantProxy_t& typed = *static_cast<const OpenDDS::RTPS::ParticipantProxy_t*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strcmp(field, "domainId") == 0) {
      return typed.domainId;
    }
    if (std::strcmp(field, "domainTag") == 0) {
      return typed.domainTag.in();
    }
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.protocolVersion, field + 16);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return typed.expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return typed.availableBuiltinEndpoints;
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      return typed.builtinEndpointQos;
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.manualLivelinessCount, field + 22);
    }
    if (std::strncmp(field, "property.", 9) == 0) {
      return getMetaStruct<DDS::PropertyQosPolicy>().getValue(&typed.property, field + 9);
    }
    if (std::strncmp(field, "opendds_participant_flags.", 26) == 0) {
      return getMetaStruct<OpenDDS::RTPS::OpenDDSParticipantFlags_t>().getValue(&typed.opendds_participant_flags, field + 26);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strcmp(field, "domainId") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'domainId' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'domainId' could not be skipped");
      }
    }
    if (std::strcmp(field, "domainTag") == 0) {
      TAO::String_Manager val;
      if (!(ser >> val.out())) {
        throw std::runtime_error("Field 'domainTag' could not be deserialized");
      }
      return val;
    } else {
      ACE_CDR::ULong len;
      if (!(ser >> len)) {
        throw std::runtime_error("String 'domainTag' length could not be deserialized");
      }
      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
        throw std::runtime_error("String 'domainTag' contents could not be skipped");
      }
    }
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 16);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0))) {
        throw std::runtime_error("Field 'protocolVersion' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0))) {
        throw std::runtime_error("Field 'vendorId' could not be skipped");
      }
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      ACE_CDR::Boolean val;
      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 1)) {
        throw std::runtime_error("Field 'expectsInlineQos' could not be skipped");
      }
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'availableBuiltinEndpoints' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'availableBuiltinEndpoints' could not be skipped");
      }
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'builtinEndpointQos' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'builtinEndpointQos' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 22);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'manualLivelinessCount' could not be skipped");
      }
    }
    if (std::strncmp(field, "property.", 9) == 0) {
      return getMetaStruct<DDS::PropertyQosPolicy>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::PropertyQosPolicy*>(0))) {
        throw std::runtime_error("Field 'property' could not be skipped");
      }
    }
    if (std::strncmp(field, "opendds_participant_flags.", 26) == 0) {
      return getMetaStruct<OpenDDS::RTPS::OpenDDSParticipantFlags_t>().getValue(ser, field + 26);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::OpenDDSParticipantFlags_t*>(0))) {
        throw std::runtime_error("Field 'opendds_participant_flags' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ParticipantProxy_t");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strcmp(field, "domainId") == 0) {
      return make_field_cmp(&T::domainId, next);
    }
    if (std::strcmp(field, "domainTag") == 0) {
      return make_field_cmp(&T::domainTag, next);
    }
    if (std::strncmp(field, "protocolVersion.", 16) == 0) {
      return make_struct_cmp(&T::protocolVersion, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return make_field_cmp(&T::expectsInlineQos, next);
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return make_field_cmp(&T::availableBuiltinEndpoints, next);
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      return make_field_cmp(&T::builtinEndpointQos, next);
    }
    if (std::strncmp(field, "manualLivelinessCount.", 22) == 0) {
      return make_struct_cmp(&T::manualLivelinessCount, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 22), next);
    }
    if (std::strncmp(field, "property.", 9) == 0) {
      return make_struct_cmp(&T::property, getMetaStruct<DDS::PropertyQosPolicy>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "opendds_participant_flags.", 26) == 0) {
      return make_struct_cmp(&T::opendds_participant_flags, getMetaStruct<OpenDDS::RTPS::OpenDDSParticipantFlags_t>().create_qc_comparator(field + 26), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"domainId", "domainTag", "protocolVersion", "guidPrefix", "vendorId", "expectsInlineQos", "availableBuiltinEndpoints", "builtinEndpointQos", "metatrafficUnicastLocatorList", "metatrafficMulticastLocatorList", "defaultMulticastLocatorList", "defaultUnicastLocatorList", "manualLivelinessCount", "property", "opendds_participant_flags", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "domainId") == 0) {
      return &static_cast<const T*>(stru)->domainId;
    }
    if (std::strcmp(field, "domainTag") == 0) {
      return &static_cast<const T*>(stru)->domainTag;
    }
    if (std::strcmp(field, "protocolVersion") == 0) {
      return &static_cast<const T*>(stru)->protocolVersion;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return &static_cast<const T*>(stru)->expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return &static_cast<const T*>(stru)->availableBuiltinEndpoints;
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      return &static_cast<const T*>(stru)->builtinEndpointQos;
    }
    if (std::strcmp(field, "metatrafficUnicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->metatrafficUnicastLocatorList;
    }
    if (std::strcmp(field, "metatrafficMulticastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->metatrafficMulticastLocatorList;
    }
    if (std::strcmp(field, "defaultMulticastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->defaultMulticastLocatorList;
    }
    if (std::strcmp(field, "defaultUnicastLocatorList") == 0) {
      return &static_cast<const T*>(stru)->defaultUnicastLocatorList;
    }
    if (std::strcmp(field, "manualLivelinessCount") == 0) {
      return &static_cast<const T*>(stru)->manualLivelinessCount;
    }
    if (std::strcmp(field, "property") == 0) {
      return &static_cast<const T*>(stru)->property;
    }
    if (std::strcmp(field, "opendds_participant_flags") == 0) {
      return &static_cast<const T*>(stru)->opendds_participant_flags;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "domainId") == 0) {
      static_cast<T*>(lhs)->domainId = *static_cast<const DDS::DomainId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "domainTag") == 0) {
      static_cast<T*>(lhs)->domainTag = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "protocolVersion") == 0) {
      static_cast<T*>(lhs)->protocolVersion = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      static_cast<T*>(lhs)->expectsInlineQos = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      static_cast<T*>(lhs)->availableBuiltinEndpoints = *static_cast<const OpenDDS::RTPS::BuiltinEndpointSet_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      static_cast<T*>(lhs)->builtinEndpointQos = *static_cast<const OpenDDS::RTPS::BuiltinEndpointQos_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "metatrafficUnicastLocatorList") == 0) {
      static_cast<T*>(lhs)->metatrafficUnicastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "metatrafficMulticastLocatorList") == 0) {
      static_cast<T*>(lhs)->metatrafficMulticastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "defaultMulticastLocatorList") == 0) {
      static_cast<T*>(lhs)->defaultMulticastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "defaultUnicastLocatorList") == 0) {
      static_cast<T*>(lhs)->defaultUnicastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "manualLivelinessCount") == 0) {
      static_cast<T*>(lhs)->manualLivelinessCount = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "property") == 0) {
      static_cast<T*>(lhs)->property = *static_cast<const DDS::PropertyQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "opendds_participant_flags") == 0) {
      static_cast<T*>(lhs)->opendds_participant_flags = *static_cast<const OpenDDS::RTPS::OpenDDSParticipantFlags_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "domainId") == 0) {
      return static_cast<const T*>(lhs)->domainId == static_cast<const T*>(rhs)->domainId;
    }
    if (std::strcmp(field, "domainTag") == 0) {
      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->domainTag.in(), static_cast<const T*>(rhs)->domainTag.in());
    }
    if (std::strcmp(field, "expectsInlineQos") == 0) {
      return static_cast<const T*>(lhs)->expectsInlineQos == static_cast<const T*>(rhs)->expectsInlineQos;
    }
    if (std::strcmp(field, "availableBuiltinEndpoints") == 0) {
      return static_cast<const T*>(lhs)->availableBuiltinEndpoints == static_cast<const T*>(rhs)->availableBuiltinEndpoints;
    }
    if (std::strcmp(field, "builtinEndpointQos") == 0) {
      return static_cast<const T*>(lhs)->builtinEndpointQos == static_cast<const T*>(rhs)->builtinEndpointQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantProxy_t)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>()
{
  static MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParticipantProxy_t*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ParticipantProxy_t>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantProxy_t */


/* Begin STRUCT: SPDPdiscoveredParticipantData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsParticipantData, size, padding);
  gen_find_size(stru.participantProxy, size, padding);
  gen_find_size(stru.leaseDuration, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsParticipantData)
    && (strm << stru.participantProxy)
    && (strm << stru.leaseDuration);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SPDPdiscoveredParticipantData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsParticipantData)
    && (strm >> stru.participantProxy)
    && (strm >> stru.leaseDuration);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData> : MetaStruct {
  typedef OpenDDS::RTPS::SPDPdiscoveredParticipantData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SPDPdiscoveredParticipantData& typed = *static_cast<const OpenDDS::RTPS::SPDPdiscoveredParticipantData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return getMetaStruct<DDS::ParticipantBuiltinTopicData>().getValue(&typed.ddsParticipantData, field + 19);
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().getValue(&typed.participantProxy, field + 17);
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Duration_t>().getValue(&typed.leaseDuration, field + 14);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return getMetaStruct<DDS::ParticipantBuiltinTopicData>().getValue(ser, field + 19);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::ParticipantBuiltinTopicData*>(0))) {
        throw std::runtime_error("Field 'ddsParticipantData' could not be skipped");
      }
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().getValue(ser, field + 17);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParticipantProxy_t*>(0))) {
        throw std::runtime_error("Field 'participantProxy' could not be skipped");
      }
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Duration_t>().getValue(ser, field + 14);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Duration_t*>(0))) {
        throw std::runtime_error("Field 'leaseDuration' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SPDPdiscoveredParticipantData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsParticipantData.", 19) == 0) {
      return make_struct_cmp(&T::ddsParticipantData, getMetaStruct<DDS::ParticipantBuiltinTopicData>().create_qc_comparator(field + 19), next);
    }
    if (std::strncmp(field, "participantProxy.", 17) == 0) {
      return make_struct_cmp(&T::participantProxy, getMetaStruct<OpenDDS::RTPS::ParticipantProxy_t>().create_qc_comparator(field + 17), next);
    }
    if (std::strncmp(field, "leaseDuration.", 14) == 0) {
      return make_struct_cmp(&T::leaseDuration, getMetaStruct<OpenDDS::RTPS::Duration_t>().create_qc_comparator(field + 14), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsParticipantData", "participantProxy", "leaseDuration", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsParticipantData") == 0) {
      return &static_cast<const T*>(stru)->ddsParticipantData;
    }
    if (std::strcmp(field, "participantProxy") == 0) {
      return &static_cast<const T*>(stru)->participantProxy;
    }
    if (std::strcmp(field, "leaseDuration") == 0) {
      return &static_cast<const T*>(stru)->leaseDuration;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsParticipantData") == 0) {
      static_cast<T*>(lhs)->ddsParticipantData = *static_cast<const DDS::ParticipantBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "participantProxy") == 0) {
      static_cast<T*>(lhs)->participantProxy = *static_cast<const OpenDDS::RTPS::ParticipantProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "leaseDuration") == 0) {
      static_cast<T*>(lhs)->leaseDuration = *static_cast<const OpenDDS::RTPS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SPDPdiscoveredParticipantData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SPDPdiscoveredParticipantData>()
{
  static MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::SPDPdiscoveredParticipantData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SPDPdiscoveredParticipantData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SPDPdiscoveredParticipantData */


/* Begin STRUCT: ParticipantMessageData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::ParticipantMessageData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.participantGuid, size, padding);
  gen_find_size(stru.data, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.participantGuid)
    && (strm << stru.data);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::ParticipantMessageData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.participantGuid)
    && (strm >> stru.data);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData> : MetaStruct {
  typedef OpenDDS::RTPS::ParticipantMessageData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::ParticipantMessageData& typed = *static_cast<const OpenDDS::RTPS::ParticipantMessageData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.participantGuid, field + 16);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 16);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0))) {
        throw std::runtime_error("Field 'participantGuid' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::ParticipantMessageData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "participantGuid.", 16) == 0) {
      return make_struct_cmp(&T::participantGuid, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 16), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"participantGuid", "data", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "participantGuid") == 0) {
      return &static_cast<const T*>(stru)->participantGuid;
    }
    if (std::strcmp(field, "data") == 0) {
      return &static_cast<const T*>(stru)->data;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "participantGuid") == 0) {
      static_cast<T*>(lhs)->participantGuid = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "data") == 0) {
      static_cast<T*>(lhs)->data = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::ParticipantMessageData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::ParticipantMessageData>()
{
  static MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::ParticipantMessageData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::ParticipantMessageData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: ParticipantMessageData */


/* Begin STRUCT: Header */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Header& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru_prefix, size, padding);
  gen_find_size(stru.version, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru_prefix)
    && (strm << stru.version)
    && (strm << stru.vendorId)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Header& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::RTPS::OctetArray4_forany stru_prefix(const_cast<OpenDDS::RTPS::OctetArray4_slice*>(stru.prefix));
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru_prefix)
    && (strm >> stru.version)
    && (strm >> stru.vendorId)
    && (strm >> stru_guidPrefix);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Header> : MetaStruct {
  typedef OpenDDS::RTPS::Header T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Header& typed = *static_cast<const OpenDDS::RTPS::Header*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.version, field + 8);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::OctetArray4_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 8);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0))) {
        throw std::runtime_error("Field 'version' could not be skipped");
      }
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0))) {
        throw std::runtime_error("Field 'vendorId' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Header");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "version.", 8) == 0) {
      return make_struct_cmp(&T::version, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"prefix", "version", "vendorId", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "prefix") == 0) {
      return &static_cast<const T*>(stru)->prefix;
    }
    if (std::strcmp(field, "version") == 0) {
      return &static_cast<const T*>(stru)->version;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "prefix") == 0) {
      OpenDDS::RTPS::OctetArray4* lhsArr = &static_cast<T*>(lhs)->prefix;
      const OpenDDS::RTPS::OctetArray4* rhsArr = static_cast<const OpenDDS::RTPS::OctetArray4*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 4; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    if (std::strcmp(field, "version") == 0) {
      static_cast<T*>(lhs)->version = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Header)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Header>()
{
  static MetaStructImpl<OpenDDS::RTPS::Header> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::Header*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::Header>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: Header */


/* Begin STRUCT: DataSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DataSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.extraFlags);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.octetsToInlineQos);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.inlineQos, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.extraFlags)
    && (strm << stru.octetsToInlineQos)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (!(stru.smHeader.flags & 2) || (strm << stru.inlineQos));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DataSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.extraFlags)
    && (strm >> stru.octetsToInlineQos)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && strm.skip(stru.octetsToInlineQos - 16)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.inlineQos));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DataSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::DataSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DataSubmessage& typed = *static_cast<const OpenDDS::RTPS::DataSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return typed.extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return typed.octetsToInlineQos;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'extraFlags' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'extraFlags' could not be skipped");
      }
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'writerSN' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParameterList*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::DataSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return make_field_cmp(&T::extraFlags, next);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return make_field_cmp(&T::octetsToInlineQos, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "extraFlags", "octetsToInlineQos", "readerId", "writerId", "writerSN", "inlineQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return &static_cast<const T*>(stru)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return &static_cast<const T*>(stru)->octetsToInlineQos;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      return &static_cast<const T*>(stru)->inlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      static_cast<T*>(lhs)->extraFlags = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      static_cast<T*>(lhs)->octetsToInlineQos = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      static_cast<T*>(lhs)->inlineQos = *static_cast<const OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "extraFlags") == 0) {
      return static_cast<const T*>(lhs)->extraFlags == static_cast<const T*>(rhs)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return static_cast<const T*>(lhs)->octetsToInlineQos == static_cast<const T*>(rhs)->octetsToInlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DataSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::DataSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::DataSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DataSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataSubmessage */


/* Begin STRUCT: DataFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DataFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.extraFlags);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.octetsToInlineQos);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.fragmentStartingNum, size, padding);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.fragmentsInSubmessage);
  if ((size + padding) % 2) {
    padding += 2 - ((size + padding) % 2);
  }
  size += gen_max_marshaled_size(stru.fragmentSize);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.sampleSize);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.inlineQos, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.extraFlags)
    && (strm << stru.octetsToInlineQos)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.fragmentStartingNum)
    && (strm << stru.fragmentsInSubmessage)
    && (strm << stru.fragmentSize)
    && (strm << stru.sampleSize)
    && (!(stru.smHeader.flags & 2) || (strm << stru.inlineQos));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DataFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.extraFlags)
    && (strm >> stru.octetsToInlineQos)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.fragmentStartingNum)
    && (strm >> stru.fragmentsInSubmessage)
    && (strm >> stru.fragmentSize)
    && (strm >> stru.sampleSize)
    && strm.skip(stru.octetsToInlineQos - 28)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.inlineQos));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::DataFragSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DataFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::DataFragSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return typed.extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return typed.octetsToInlineQos;
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.fragmentStartingNum, field + 20);
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return typed.fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return typed.fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return typed.sampleSize;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'extraFlags' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'extraFlags' could not be skipped");
      }
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'octetsToInlineQos' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'writerSN' could not be skipped");
      }
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 20);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0))) {
        throw std::runtime_error("Field 'fragmentStartingNum' could not be skipped");
      }
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fragmentsInSubmessage' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'fragmentsInSubmessage' could not be skipped");
      }
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      ACE_CDR::UShort val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'fragmentSize' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 2)) {
        throw std::runtime_error("Field 'fragmentSize' could not be skipped");
      }
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      ACE_CDR::ULong val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'sampleSize' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'sampleSize' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::ParameterList*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::DataFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return make_field_cmp(&T::extraFlags, next);
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return make_field_cmp(&T::octetsToInlineQos, next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "fragmentStartingNum.", 20) == 0) {
      return make_struct_cmp(&T::fragmentStartingNum, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 20), next);
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return make_field_cmp(&T::fragmentsInSubmessage, next);
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return make_field_cmp(&T::fragmentSize, next);
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return make_field_cmp(&T::sampleSize, next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "extraFlags", "octetsToInlineQos", "readerId", "writerId", "writerSN", "fragmentStartingNum", "fragmentsInSubmessage", "fragmentSize", "sampleSize", "inlineQos", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      return &static_cast<const T*>(stru)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return &static_cast<const T*>(stru)->octetsToInlineQos;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "fragmentStartingNum") == 0) {
      return &static_cast<const T*>(stru)->fragmentStartingNum;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return &static_cast<const T*>(stru)->fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return &static_cast<const T*>(stru)->fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return &static_cast<const T*>(stru)->sampleSize;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      return &static_cast<const T*>(stru)->inlineQos;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "extraFlags") == 0) {
      static_cast<T*>(lhs)->extraFlags = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      static_cast<T*>(lhs)->octetsToInlineQos = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentStartingNum") == 0) {
      static_cast<T*>(lhs)->fragmentStartingNum = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      static_cast<T*>(lhs)->fragmentsInSubmessage = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      static_cast<T*>(lhs)->fragmentSize = *static_cast<const CORBA::UShort*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      static_cast<T*>(lhs)->sampleSize = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "inlineQos") == 0) {
      static_cast<T*>(lhs)->inlineQos = *static_cast<const OpenDDS::RTPS::ParameterList*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "extraFlags") == 0) {
      return static_cast<const T*>(lhs)->extraFlags == static_cast<const T*>(rhs)->extraFlags;
    }
    if (std::strcmp(field, "octetsToInlineQos") == 0) {
      return static_cast<const T*>(lhs)->octetsToInlineQos == static_cast<const T*>(rhs)->octetsToInlineQos;
    }
    if (std::strcmp(field, "fragmentsInSubmessage") == 0) {
      return static_cast<const T*>(lhs)->fragmentsInSubmessage == static_cast<const T*>(rhs)->fragmentsInSubmessage;
    }
    if (std::strcmp(field, "fragmentSize") == 0) {
      return static_cast<const T*>(lhs)->fragmentSize == static_cast<const T*>(rhs)->fragmentSize;
    }
    if (std::strcmp(field, "sampleSize") == 0) {
      return static_cast<const T*>(lhs)->sampleSize == static_cast<const T*>(rhs)->sampleSize;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DataFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DataFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::DataFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DataFragSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DataFragSubmessage */


/* Begin STRUCT: HeartBeatSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::HeartBeatSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.firstSN, size, padding);
  gen_find_size(stru.lastSN, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.firstSN)
    && (strm << stru.lastSN)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::HeartBeatSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.firstSN)
    && (strm >> stru.lastSN)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::HeartBeatSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::HeartBeatSubmessage& typed = *static_cast<const OpenDDS::RTPS::HeartBeatSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.firstSN, field + 8);
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.lastSN, field + 7);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 8);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'firstSN' could not be skipped");
      }
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 7);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'lastSN' could not be skipped");
      }
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::HeartBeatSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "firstSN.", 8) == 0) {
      return make_struct_cmp(&T::firstSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "lastSN.", 7) == 0) {
      return make_struct_cmp(&T::lastSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 7), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "firstSN", "lastSN", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "firstSN") == 0) {
      return &static_cast<const T*>(stru)->firstSN;
    }
    if (std::strcmp(field, "lastSN") == 0) {
      return &static_cast<const T*>(stru)->lastSN;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "firstSN") == 0) {
      static_cast<T*>(lhs)->firstSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lastSN") == 0) {
      static_cast<T*>(lhs)->lastSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::HeartBeatSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::HeartBeatSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::HeartBeatSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HeartBeatSubmessage */


/* Begin STRUCT: HeartBeatFragSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::HeartBeatFragSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.readerId, size, padding);
  gen_find_size(stru.writerId, size, padding);
  gen_find_size(stru.writerSN, size, padding);
  gen_find_size(stru.lastFragmentNum, size, padding);
  gen_find_size(stru.count, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.readerId)
    && (strm << stru.writerId)
    && (strm << stru.writerSN)
    && (strm << stru.lastFragmentNum)
    && (strm << stru.count);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::HeartBeatFragSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.readerId)
    && (strm >> stru.writerId)
    && (strm >> stru.writerSN)
    && (strm >> stru.lastFragmentNum)
    && (strm >> stru.count);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::HeartBeatFragSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::HeartBeatFragSubmessage& typed = *static_cast<const OpenDDS::RTPS::HeartBeatFragSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.readerId, field + 9);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.writerId, field + 9);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(&typed.writerSN, field + 9);
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(&typed.lastFragmentNum, field + 16);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(&typed.count, field + 6);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'readerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
        throw std::runtime_error("Field 'writerId' could not be skipped");
      }
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SequenceNumber_t*>(0))) {
        throw std::runtime_error("Field 'writerSN' could not be skipped");
      }
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().getValue(ser, field + 16);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::FragmentNumber_t*>(0))) {
        throw std::runtime_error("Field 'lastFragmentNum' could not be skipped");
      }
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Count_t>().getValue(ser, field + 6);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Count_t*>(0))) {
        throw std::runtime_error("Field 'count' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::HeartBeatFragSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "readerId.", 9) == 0) {
      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerId.", 9) == 0) {
      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "writerSN.", 9) == 0) {
      return make_struct_cmp(&T::writerSN, getMetaStruct<OpenDDS::RTPS::SequenceNumber_t>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "lastFragmentNum.", 16) == 0) {
      return make_struct_cmp(&T::lastFragmentNum, getMetaStruct<OpenDDS::RTPS::FragmentNumber_t>().create_qc_comparator(field + 16), next);
    }
    if (std::strncmp(field, "count.", 6) == 0) {
      return make_struct_cmp(&T::count, getMetaStruct<OpenDDS::RTPS::Count_t>().create_qc_comparator(field + 6), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "readerId", "writerId", "writerSN", "lastFragmentNum", "count", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "readerId") == 0) {
      return &static_cast<const T*>(stru)->readerId;
    }
    if (std::strcmp(field, "writerId") == 0) {
      return &static_cast<const T*>(stru)->writerId;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      return &static_cast<const T*>(stru)->writerSN;
    }
    if (std::strcmp(field, "lastFragmentNum") == 0) {
      return &static_cast<const T*>(stru)->lastFragmentNum;
    }
    if (std::strcmp(field, "count") == 0) {
      return &static_cast<const T*>(stru)->count;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "readerId") == 0) {
      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerId") == 0) {
      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "writerSN") == 0) {
      static_cast<T*>(lhs)->writerSN = *static_cast<const OpenDDS::RTPS::SequenceNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "lastFragmentNum") == 0) {
      static_cast<T*>(lhs)->lastFragmentNum = *static_cast<const OpenDDS::RTPS::FragmentNumber_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "count") == 0) {
      static_cast<T*>(lhs)->count = *static_cast<const OpenDDS::RTPS::Count_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::HeartBeatFragSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::HeartBeatFragSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::HeartBeatFragSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::HeartBeatFragSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: HeartBeatFragSubmessage */


/* Begin STRUCT: InfoDestinationSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoDestinationSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.smHeader)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoDestinationSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.smHeader)
    && (strm >> stru_guidPrefix);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoDestinationSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoDestinationSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoDestinationSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoDestinationSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoDestinationSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoDestinationSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoDestinationSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoDestinationSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoDestinationSubmessage */


/* Begin STRUCT: InfoSourceSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoSourceSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  gen_find_size(stru.smHeader, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.unused);
  gen_find_size(stru.version, size, padding);
  gen_find_size(stru.vendorId, size, padding);
  gen_find_size(stru_guidPrefix, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm << stru.smHeader)
    && (strm << stru.unused)
    && (strm << stru.version)
    && (strm << stru.vendorId)
    && (strm << stru_guidPrefix);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoSourceSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
  return (strm >> stru.smHeader)
    && (strm >> stru.unused)
    && (strm >> stru.version)
    && (strm >> stru.vendorId)
    && (strm >> stru_guidPrefix);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoSourceSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoSourceSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoSourceSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strcmp(field, "unused") == 0) {
      return typed.unused;
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(&typed.version, field + 8);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(&typed.vendorId, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strcmp(field, "unused") == 0) {
      ACE_CDR::Long val;
      if (!(ser >> val)) {
        throw std::runtime_error("Field 'unused' could not be deserialized");
      }
      return val;
    } else {
      if (!ser.skip(1, 4)) {
        throw std::runtime_error("Field 'unused' could not be skipped");
      }
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().getValue(ser, field + 8);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::ProtocolVersion_t*>(0))) {
        throw std::runtime_error("Field 'version' could not be skipped");
      }
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::VendorId_t>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::VendorId_t*>(0))) {
        throw std::runtime_error("Field 'vendorId' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoSourceSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strcmp(field, "unused") == 0) {
      return make_field_cmp(&T::unused, next);
    }
    if (std::strncmp(field, "version.", 8) == 0) {
      return make_struct_cmp(&T::version, getMetaStruct<OpenDDS::RTPS::ProtocolVersion_t>().create_qc_comparator(field + 8), next);
    }
    if (std::strncmp(field, "vendorId.", 9) == 0) {
      return make_struct_cmp(&T::vendorId, getMetaStruct<OpenDDS::RTPS::VendorId_t>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unused", "version", "vendorId", "guidPrefix", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unused") == 0) {
      return &static_cast<const T*>(stru)->unused;
    }
    if (std::strcmp(field, "version") == 0) {
      return &static_cast<const T*>(stru)->version;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      return &static_cast<const T*>(stru)->vendorId;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      return &static_cast<const T*>(stru)->guidPrefix;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unused") == 0) {
      static_cast<T*>(lhs)->unused = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "version") == 0) {
      static_cast<T*>(lhs)->version = *static_cast<const OpenDDS::RTPS::ProtocolVersion_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "vendorId") == 0) {
      static_cast<T*>(lhs)->vendorId = *static_cast<const OpenDDS::RTPS::VendorId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "guidPrefix") == 0) {
      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
        (*lhsArr)[i0] = (*rhsArr)[i0];
      }
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "unused") == 0) {
      return static_cast<const T*>(lhs)->unused == static_cast<const T*>(rhs)->unused;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoSourceSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoSourceSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoSourceSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoSourceSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoSourceSubmessage */


/* Begin STRUCT: InfoTimestampSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoTimestampSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  if (!(stru.smHeader.flags & 2)) {
    gen_find_size(stru.timestamp, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (!(!(stru.smHeader.flags & 2)) || (strm << stru.timestamp));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoTimestampSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (!(!(stru.smHeader.flags & 2)) || (strm >> stru.timestamp));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoTimestampSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoTimestampSubmessage& typed = *static_cast<const OpenDDS::RTPS::InfoTimestampSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Timestamp_t>().getValue(&typed.timestamp, field + 10);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return getMetaStruct<OpenDDS::RTPS::Timestamp_t>().getValue(ser, field + 10);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::Timestamp_t*>(0))) {
        throw std::runtime_error("Field 'timestamp' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoTimestampSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "timestamp.", 10) == 0) {
      return make_struct_cmp(&T::timestamp, getMetaStruct<OpenDDS::RTPS::Timestamp_t>().create_qc_comparator(field + 10), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "timestamp", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "timestamp") == 0) {
      return &static_cast<const T*>(stru)->timestamp;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "timestamp") == 0) {
      static_cast<T*>(lhs)->timestamp = *static_cast<const OpenDDS::RTPS::Timestamp_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoTimestampSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoTimestampSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoTimestampSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoTimestampSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoTimestampSubmessage */


/* Begin STRUCT: PadSubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::PadSubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::PadSubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::PadSubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::PadSubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::PadSubmessage& typed = *static_cast<const OpenDDS::RTPS::PadSubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::PadSubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::PadSubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::PadSubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::PadSubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::PadSubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::PadSubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: PadSubmessage */


/* Begin STRUCT: InfoReplyIp4Submessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::InfoReplyIp4Submessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  gen_find_size(stru.unicastLocator, size, padding);
  if (stru.smHeader.flags & 2) {
    gen_find_size(stru.multicastLocator, size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && (strm << stru.unicastLocator)
    && (!(stru.smHeader.flags & 2) || (strm << stru.multicastLocator));
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::InfoReplyIp4Submessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.smHeader)
    && (strm >> stru.unicastLocator)
    && (!(stru.smHeader.flags & 2) || (strm >> stru.multicastLocator));
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage> : MetaStruct {
  typedef OpenDDS::RTPS::InfoReplyIp4Submessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::InfoReplyIp4Submessage& typed = *static_cast<const OpenDDS::RTPS::InfoReplyIp4Submessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(&typed.unicastLocator, field + 15);
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(&typed.multicastLocator, field + 17);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, field + 15);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorUDPv4_t*>(0))) {
        throw std::runtime_error("Field 'unicastLocator' could not be skipped");
      }
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().getValue(ser, field + 17);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::LocatorUDPv4_t*>(0))) {
        throw std::runtime_error("Field 'multicastLocator' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::InfoReplyIp4Submessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    if (std::strncmp(field, "unicastLocator.", 15) == 0) {
      return make_struct_cmp(&T::unicastLocator, getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().create_qc_comparator(field + 15), next);
    }
    if (std::strncmp(field, "multicastLocator.", 17) == 0) {
      return make_struct_cmp(&T::multicastLocator, getMetaStruct<OpenDDS::RTPS::LocatorUDPv4_t>().create_qc_comparator(field + 17), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "unicastLocator", "multicastLocator", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "unicastLocator") == 0) {
      return &static_cast<const T*>(stru)->unicastLocator;
    }
    if (std::strcmp(field, "multicastLocator") == 0) {
      return &static_cast<const T*>(stru)->multicastLocator;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "unicastLocator") == 0) {
      static_cast<T*>(lhs)->unicastLocator = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multicastLocator") == 0) {
      static_cast<T*>(lhs)->multicastLocator = *static_cast<const OpenDDS::RTPS::LocatorUDPv4_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::InfoReplyIp4Submessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::InfoReplyIp4Submessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::InfoReplyIp4Submessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::InfoReplyIp4Submessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: InfoReplyIp4Submessage */


/* Begin STRUCT: SecuritySubmessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SecuritySubmessage& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.smHeader, size, padding);
  size += stru.content.length() * max_marshaled_size_octet();
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SecuritySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.smHeader)
    && strm.write_octet_array(stru.content.get_buffer(), stru.content.length());
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SecuritySubmessage& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  if (strm >> stru.smHeader) {
    stru.content.length(stru.smHeader.submessageLength);
    if (strm.read_octet_array(stru.content.get_buffer(),
                              stru.smHeader.submessageLength)) {
      return true;
    }
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::SecuritySubmessage> : MetaStruct {
  typedef OpenDDS::RTPS::SecuritySubmessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::SecuritySubmessage& typed = *static_cast<const OpenDDS::RTPS::SecuritySubmessage*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(&typed.smHeader, field + 9);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SecuritySubmessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().getValue(ser, field + 9);
    } else {
      if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) {
        throw std::runtime_error("Field 'smHeader' could not be skipped");
      }
    }
    if (!gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0))) {
      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::SecuritySubmessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "smHeader.", 9) == 0) {
      return make_struct_cmp(&T::smHeader, getMetaStruct<OpenDDS::RTPS::SubmessageHeader>().create_qc_comparator(field + 9), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SecuritySubmessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"smHeader", "content", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "smHeader") == 0) {
      return &static_cast<const T*>(stru)->smHeader;
    }
    if (std::strcmp(field, "content") == 0) {
      return &static_cast<const T*>(stru)->content;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SecuritySubmessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "smHeader") == 0) {
      static_cast<T*>(lhs)->smHeader = *static_cast<const OpenDDS::RTPS::SubmessageHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "content") == 0) {
      static_cast<T*>(lhs)->content = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SecuritySubmessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::SecuritySubmessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::SecuritySubmessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::SecuritySubmessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::SecuritySubmessage*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::SecuritySubmessage>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: SecuritySubmessage */


/* Begin ENUM: SubmessageKind */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  return strm << static_cast<CORBA::ULong>(enumval);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageKind& enumval)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(enumval);
  CORBA::ULong temp = 0;
  if (strm >> temp) {
    enumval = static_cast<OpenDDS::RTPS::SubmessageKind>(temp);
    return true;
  }
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

const char* gen_OpenDDS_RTPS_SubmessageKind_names[] = {
  "SUBMESSAGE_NONE",
  "PAD",
  "RESERVED_2",
  "RESERVED_3",
  "RESERVED_4",
  "RESERVED_5",
  "ACKNACK",
  "HEARTBEAT",
  "GAP",
  "INFO_TS",
  "RESERVED_10",
  "RESERVED_11",
  "INFO_SRC",
  "INFO_REPLY_IP4",
  "INFO_DST",
  "INFO_REPLY",
  "RESERVED_16",
  "RESERVED_17",
  "NACK_FRAG",
  "HEARTBEAT_FRAG",
  "RESERVED_20",
  "DATA",
  "DATA_FRAG",
  "RESERVED_23",
  "RESERVED_24",
  "RESERVED_25",
  "RESERVED_26",
  "RESERVED_27",
  "RESERVED_28",
  "RESERVED_29",
  "RESERVED_30",
  "RESERVED_31",
  "RESERVED_32",
  "RESERVED_33",
  "RESERVED_34",
  "RESERVED_35",
  "RESERVED_36",
  "RESERVED_37",
  "RESERVED_38",
  "RESERVED_39",
  "RESERVED_40",
  "RESERVED_41",
  "RESERVED_42",
  "RESERVED_43",
  "RESERVED_44",
  "RESERVED_45",
  "RESERVED_46",
  "RESERVED_47",
  "SEC_BODY",
  "SEC_PREFIX",
  "SEC_POSTFIX",
  "SRTPS_PREFIX",
  "SRTPS_POSTFIX",
  "RESERVED_53_SECURITY"
};
const size_t gen_OpenDDS_RTPS_SubmessageKind_names_size = 54;
}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End ENUM: SubmessageKind */


/* Begin UNION: Submessage */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::Submessage& uni, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(uni);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  switch (uni._d()) {
  case OpenDDS::RTPS::PAD: {
    gen_find_size(uni.pad_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::ACKNACK: {
    gen_find_size(uni.acknack_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::HEARTBEAT: {
    gen_find_size(uni.heartbeat_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::GAP: {
    gen_find_size(uni.gap_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::INFO_TS: {
    gen_find_size(uni.info_ts_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::INFO_SRC: {
    gen_find_size(uni.info_src_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::INFO_REPLY_IP4: {
    gen_find_size(uni.info_reply_ipv4_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::INFO_DST: {
    gen_find_size(uni.info_dst_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::INFO_REPLY: {
    gen_find_size(uni.info_reply_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::NACK_FRAG: {
    gen_find_size(uni.nack_frag_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::HEARTBEAT_FRAG: {
    gen_find_size(uni.hb_frag_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::DATA: {
    gen_find_size(uni.data_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::DATA_FRAG: {
    gen_find_size(uni.data_frag_sm(), size, padding);
    break;
  }
  case OpenDDS::RTPS::SEC_BODY:
  case OpenDDS::RTPS::SEC_PREFIX:
  case OpenDDS::RTPS::SEC_POSTFIX:
  case OpenDDS::RTPS::SRTPS_PREFIX:
  case OpenDDS::RTPS::SRTPS_POSTFIX: {
    gen_find_size(uni.security_sm(), size, padding);
    break;
  }
  default: {
    gen_find_size(uni.unknown_sm(), size, padding);
    break;
  }
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  switch (uni._d()) {
  case OpenDDS::RTPS::PAD: {
    return (strm << uni.pad_sm());
  }
  case OpenDDS::RTPS::ACKNACK: {
    return (strm << uni.acknack_sm());
  }
  case OpenDDS::RTPS::HEARTBEAT: {
    return (strm << uni.heartbeat_sm());
  }
  case OpenDDS::RTPS::GAP: {
    return (strm << uni.gap_sm());
  }
  case OpenDDS::RTPS::INFO_TS: {
    return (strm << uni.info_ts_sm());
  }
  case OpenDDS::RTPS::INFO_SRC: {
    return (strm << uni.info_src_sm());
  }
  case OpenDDS::RTPS::INFO_REPLY_IP4: {
    return (strm << uni.info_reply_ipv4_sm());
  }
  case OpenDDS::RTPS::INFO_DST: {
    return (strm << uni.info_dst_sm());
  }
  case OpenDDS::RTPS::INFO_REPLY: {
    return (strm << uni.info_reply_sm());
  }
  case OpenDDS::RTPS::NACK_FRAG: {
    return (strm << uni.nack_frag_sm());
  }
  case OpenDDS::RTPS::HEARTBEAT_FRAG: {
    return (strm << uni.hb_frag_sm());
  }
  case OpenDDS::RTPS::DATA: {
    return (strm << uni.data_sm());
  }
  case OpenDDS::RTPS::DATA_FRAG: {
    return (strm << uni.data_frag_sm());
  }
  case OpenDDS::RTPS::SEC_BODY:
  case OpenDDS::RTPS::SEC_PREFIX:
  case OpenDDS::RTPS::SEC_POSTFIX:
  case OpenDDS::RTPS::SRTPS_PREFIX:
  case OpenDDS::RTPS::SRTPS_POSTFIX: {
    return (strm << uni.security_sm());
  }
  default: {
    return (strm << uni.unknown_sm());
  }
  }
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::Submessage& uni)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(uni);
  // unused
  return false;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::Submessage> : MetaStruct {
  typedef OpenDDS::RTPS::Submessage T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::Submessage& typed = *static_cast<const OpenDDS::RTPS::Submessage*>(stru);
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Submessage)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    ACE_UNUSED_ARG(ser);
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::Submessage");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Submessage)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    ACE_UNUSED_ARG(stru);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Submessage)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Submessage)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::Submessage)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::Submessage>()
{
  static MetaStructImpl<OpenDDS::RTPS::Submessage> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::Submessage*)
{
  ACE_UNUSED_ARG(ser);
  OpenDDS::RTPS::SubmessageKind disc;
  if (!(ser >> disc)) {
    return false;
  }
  switch (disc) {
  case OpenDDS::RTPS::PAD: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::PadSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::ACKNACK: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::AckNackSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::HEARTBEAT: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::HeartBeatSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::GAP: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::GapSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::INFO_TS: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoTimestampSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::INFO_SRC: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoSourceSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::INFO_REPLY_IP4: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoReplyIp4Submessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::INFO_DST: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoDestinationSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::INFO_REPLY: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::InfoReplySubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::NACK_FRAG: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::NackFragSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::HEARTBEAT_FRAG: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::HeartBeatFragSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::DATA: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::DataSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::DATA_FRAG: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::DataFragSubmessage*>(0))) return false;
    return true;
  }
  case OpenDDS::RTPS::SEC_BODY:
  case OpenDDS::RTPS::SEC_PREFIX:
  case OpenDDS::RTPS::SEC_POSTFIX:
  case OpenDDS::RTPS::SRTPS_PREFIX:
  case OpenDDS::RTPS::SRTPS_POSTFIX: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SecuritySubmessage*>(0))) return false;
    return true;
  }
  default: {
    if (!gen_skip_over(ser, static_cast<OpenDDS::RTPS::SubmessageHeader*>(0))) return false;
    return true;
  }
  }
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End UNION: Submessage */


/* Begin TYPEDEF: SubmessageSeq */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::SubmessageSeq& seq, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(seq);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  find_size_ulong(size, padding);
  if (seq.length() == 0) {
    return;
  }
  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    gen_find_size(seq[i], size, padding);
  }
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  const CORBA::ULong length = seq.length();
  if (!(strm << length)) {
    return false;
  }
  if (length == 0) {
    return true;
  }
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm << seq[i])) {
      return false;
    }
  }
  return true;
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::SubmessageSeq& seq)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(seq);
  CORBA::ULong length;
  if (!(strm >> length)) {
    return false;
  }
  seq.length(length);
  for (CORBA::ULong i = 0; i < length; ++i) {
    if (!(strm >> seq[i])) {
      return false;
    }
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::SubmessageSeq*)
{
  ACE_UNUSED_ARG(ser);
  ACE_CDR::ULong length;
  if (!(ser >> length)) return false;
  for (ACE_CDR::ULong i = 0; i < length; ++i) {
  }
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End TYPEDEF: SubmessageSeq */


/* Begin STRUCT: DiscoveredTopicData */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void gen_find_size(const OpenDDS::RTPS::DiscoveredTopicData& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.ddsTopicData, size, padding);
}

bool operator<<(Serializer& strm, const OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.ddsTopicData);
}

bool operator>>(Serializer& strm, OpenDDS::RTPS::DiscoveredTopicData& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.ddsTopicData);
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData> : MetaStruct {
  typedef OpenDDS::RTPS::DiscoveredTopicData T;

#ifndef OPENDDS_NO_MULTI_TOPIC
  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool isDcpsKey(const char* field) const
  {
    ACE_UNUSED_ARG(field);
    return false;
  }

  Value getValue(const void* stru, const char* field) const
  {
    const OpenDDS::RTPS::DiscoveredTopicData& typed = *static_cast<const OpenDDS::RTPS::DiscoveredTopicData*>(stru);
    ACE_UNUSED_ARG(typed);
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return getMetaStruct<DDS::TopicBuiltinTopicData>().getValue(&typed.ddsTopicData, field + 13);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  Value getValue(Serializer& ser, const char* field) const
  {
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return getMetaStruct<DDS::TopicBuiltinTopicData>().getValue(ser, field + 13);
    } else {
      if (!gen_skip_over(ser, static_cast<DDS::TopicBuiltinTopicData*>(0))) {
        throw std::runtime_error("Field 'ddsTopicData' could not be skipped");
      }
    }
    if (!field[0]) {
      return 0;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::RTPS::DiscoveredTopicData");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "ddsTopicData.", 13) == 0) {
      return make_struct_cmp(&T::ddsTopicData, getMetaStruct<DDS::TopicBuiltinTopicData>().create_qc_comparator(field + 13), next);
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

#ifndef OPENDDS_NO_MULTI_TOPIC
  const char** getFieldNames() const
  {
    static const char* names[] = {"ddsTopicData", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "ddsTopicData") == 0) {
      return &static_cast<const T*>(stru)->ddsTopicData;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "ddsTopicData") == 0) {
      static_cast<T*>(lhs)->ddsTopicData = *static_cast<const DDS::TopicBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }
#endif /* OPENDDS_NO_MULTI_TOPIC */

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::RTPS::DiscoveredTopicData)");
  }
};

template<>
const MetaStruct& getMetaStruct<OpenDDS::RTPS::DiscoveredTopicData>()
{
  static MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData> msi;
  return msi;
}

bool gen_skip_over(Serializer& ser, OpenDDS::RTPS::DiscoveredTopicData*)
{
  ACE_UNUSED_ARG(ser);
  MetaStructImpl<OpenDDS::RTPS::DiscoveredTopicData>().getValue(ser, "");
  return true;
}

}  }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif

/* End STRUCT: DiscoveredTopicData */

/* End MODULE: RTPS */

/* End MODULE: OpenDDS */
